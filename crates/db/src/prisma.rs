// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use std::{path::Path, sync::Arc};

use prisma_client_rust::{
  bigdecimal::{self, FromPrimitive},
  chrono,
  datamodel::parse_configuration,
  operator::Operator,
  prisma_models::{InternalDataModelBuilder, PrismaValue},
  queries::{QueryContext, QueryInfo, Result as QueryResult},
  query_core::{
    executor,
    schema_builder,
    BuildMode,
    CoreError,
    InterpreterError,
    QueryExecutor,
    QueryGraphBuilderError,
    QuerySchema,
    QueryValue,
    Selection,
  },
  serde_json,
  transform_equals,
  BatchResult,
  Direction,
  ManyArgs,
  SerializedWhere,
  SerializedWhereValue,
  UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
static DATAMODEL_STR : & 'static str = "// => CLIENT START\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n  referentialIntegrity = \"prisma\"\n}\n\ngenerator client {\n  provider      = \"pnpm generate:rust\"\n  output        = \"../../crates/db/src/prisma.rs\"\n  binaryTargets = [\"native\"]\n  previewFeatures = [\"referentialIntegrity\"]\n}\n\n// => CLIENT END\n\n/// Users can have multiple ID's\nmodel Account {\n  /// The account id.\n  id                    String   @id @default(cuid())\n  /// The userId on the authentication service.\n  userId                String   @map(\"user_id\")\n  /// The type of account.\n  accountType           String   @map(\"account_type\")\n  /// The name of the provider for this account. In this case GitHub is the only\n  /// option.\n  provider              String\n  providerAccountId     String   @map(\"provider_account_id\")\n  refreshToken          String?  @map(\"refresh_token\") @db.Text\n  /// This is a GitHub login specific field which allows for next-auth to\n  //automatically refresh the token.\n  refreshTokenExpiresIn Int?     @map(\"refresh_token_expires_in\")\n  /// The access token for this account.\n  accessToken           String?  @map(\"access_token\") @db.Text\n  /// The timestamp of when the token expires.\n  expiresAt             Int?     @map(\"expires_at\")\n  tokenType             String?  @map(\"token_type\")\n  scope                 String?\n  idToken               String?  @map(\"id_token\") @db.Text\n  sessionState          String?  @map(\"session_state\")\n  oauthTokenSecret      String?  @map(\"oauth_token_secret\")\n  oauthToken            String?  @map(\"oauth_token\")\n  /// When the database record was first created.\n  createdAt             DateTime @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt             DateTime @updatedAt @map(\"updated_at\")\n  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n  @@map(\"accounts\")\n}\n\n/// A user model. Be careful when populating to avoid sending sensitive data to\n/// the client.\n///\n/// It might be worthwhile splitting up the model for safety in the future.\nmodel User {\n  /// The user id.\n  id           String       @id @default(cuid())\n  /// The name of the user which is retrieved from their GitHub profile when\n  /// signing up.\n  name         String?\n  /// The primary email address for this user. Only verified email address can\n  /// be set as primary.\n  primaryEmail String?      @map(\"primary_email\")\n  /// The emails for this user.\n  emails       Email[]\n  /// A profile image url if one exists.\n  image        String?\n  /// The user password is seperated from the user to prevent unitentionally\n  /// sending it to the client.\n  password     Password?\n  /// Connected authentication accounts for this user.\n  accounts     Account[]\n  /// A user can attach multiple wallets to their profile. Once attached a\n  /// wallet can be used to sign in.\n  wallets      UserWallet[]\n  /// Projects created by this user.\n  projects     Project[]\n  /// When the database record was first created.\n  createdAt    DateTime     @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt    DateTime     @updatedAt @map(\"updated_at\")\n\n  @@map(\"users\")\n}\n\n/// Rather than storing a single email per user, a user may store multiple email\n/// address and set one as their primary.\nmodel Email {\n  /// The primary email address for this user.\n  email         String?   @unique\n  /// The date the email was verified.\n  emailVerified DateTime? @map(\"email_verified\")\n  /// The userId field for the relation.\n  userId        String    @unique @map(\"user_id\")\n  /// When the database record was first created.\n  createdAt     DateTime  @default(now()) @map(\"created_at\")\n  /// The owner of this email address.\n  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n  @@map(\"verificationtokens\")\n}\n\n/// Each wallet can be attached to a maximum of one user.\nmodel UserWallet {\n  /// The wallet public key. If a user wants to transfer the wallet to another\n  /// user they must first delete it from their current user account.\n  publicKey String   @unique @map(\"public_key\")\n  /// The userId field for the relation.\n  userId    String   @map(\"user_id\")\n  /// When the database record was first created.\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  /// The owner of this wallet.\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel Password {\n  /// The hashed password.\n  hash   String\n  /// The user this password is for.\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  /// The user id for the relation.\n  userId String @unique @map(\"user_id\")\n}\n\nmodel Project {\n  /// The project id.\n  id          String       @id @default(cuid())\n  /// The project title.\n  title       String\n  /// The project description as a markdown compatible string.\n  description String\n  /// When the database record was first created.\n  createdAt   DateTime     @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt   DateTime     @updatedAt @map(\"updated_at\")\n  /// The owner of this project.\n  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  /// The id of the user that owns this project.\n  userId      String       @map(\"user_id\")\n  /// The list of github repos that are associated with this project.\n  githubRepos GitHubRepo[]\n}\n\n/// Link to a GitHub project.\nmodel GitHubRepo {\n  /// The github repo id.\n  id    String @id @default(cuid())\n  /// The github repo owner.\n  owner String\n  /// The github repo name.\n  name  String\n\n  /// The project this repo is linked to. A repo can only be linked to one\n  /// project. This means that once a repo is added to a project it can't be\n  /// added to another one.\n  project   Project? @relation(fields: [projectId], references: [id])\n  projectId String?\n\n  @@unique([owner, name])\n}\n" ;
static DATABASE_STR: &'static str = "mysql";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let url = if let Some(url) = source.load_shadow_database_url()? {
    url
  } else {
    source.load_url(|key| std::env::var(key).ok())?
  };
  let url = if url.starts_with("file:") {
    let path = url.split(":").nth(1).unwrap();
    if Path::new("./schema.prisma").exists() {
      url
    } else if Path::new("./prisma/schema.prisma").exists() {
      format!("file:./prisma/{}", path)
    } else {
      url
    }
  } else {
    url
  };
  new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let (db_name, executor) = executor::load(&source, &[], &url).await?;
  let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
  let query_schema = Arc::new(schema_builder::build(
    internal_model,
    BuildMode::Modern,
    true,
    source.capabilities(),
    vec![],
    source.referential_integrity(),
  ));
  executor.primary_connector().get_connection().await?;
  Ok(PrismaClient::_new(executor, query_schema))
}
pub mod account {
  use super::{_prisma::*, *};
  pub mod id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod user_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::UserIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UserId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UserIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UserIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UserIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UserIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UserIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UserIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UserIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UserIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUserId(value.0)
      }
    }
  }
  pub mod account_type {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::AccountTypeEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::AccountType(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccountTypeInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccountTypeNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AccountTypeLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AccountTypeLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AccountTypeGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AccountTypeGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AccountTypeContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AccountTypeStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AccountTypeEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AccountTypeNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAccountType(value.0)
      }
    }
  }
  pub mod provider {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ProviderEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Provider(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProviderInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProviderNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ProviderLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ProviderLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ProviderGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ProviderGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ProviderContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ProviderStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ProviderEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ProviderNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetProvider(value.0)
      }
    }
  }
  pub mod provider_account_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ProviderAccountId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProviderAccountIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProviderAccountIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ProviderAccountIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetProviderAccountId(value.0)
      }
    }
  }
  pub mod refresh_token {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::RefreshTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::RefreshToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::RefreshTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::RefreshTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::RefreshTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::RefreshTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::RefreshTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::RefreshTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::RefreshTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::RefreshTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::RefreshTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::RefreshTokenNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetRefreshToken(value.0)
      }
    }
  }
  pub mod refresh_token_expires_in {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<i32>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<i32>) -> WhereParam {
      WhereParam::RefreshTokenExpiresInEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::RefreshTokenExpiresIn(direction)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::RefreshTokenExpiresInInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::RefreshTokenExpiresInNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::RefreshTokenExpiresInLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::RefreshTokenExpiresInLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::RefreshTokenExpiresInGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::RefreshTokenExpiresInGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::RefreshTokenExpiresInNot(value)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementRefreshTokenExpiresIn(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementRefreshTokenExpiresIn(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyRefreshTokenExpiresIn(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideRefreshTokenExpiresIn(value)
    }
    pub struct Set(Option<i32>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetRefreshTokenExpiresIn(value.0)
      }
    }
  }
  pub mod access_token {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::AccessTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::AccessToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccessTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::AccessTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::AccessTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::AccessTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::AccessTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::AccessTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::AccessTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::AccessTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::AccessTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::AccessTokenNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetAccessToken(value.0)
      }
    }
  }
  pub mod expires_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<i32>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<i32>) -> WhereParam {
      WhereParam::ExpiresAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ExpiresAt(direction)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::ExpiresAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::ExpiresAtNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::ExpiresAtLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::ExpiresAtLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::ExpiresAtGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::ExpiresAtGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::ExpiresAtNot(value)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementExpiresAt(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementExpiresAt(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyExpiresAt(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideExpiresAt(value)
    }
    pub struct Set(Option<i32>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetExpiresAt(value.0)
      }
    }
  }
  pub mod token_type {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::TokenTypeEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::TokenType(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TokenTypeInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TokenTypeNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::TokenTypeLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::TokenTypeLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::TokenTypeGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::TokenTypeGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::TokenTypeContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::TokenTypeStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::TokenTypeEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::TokenTypeNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetTokenType(value.0)
      }
    }
  }
  pub mod scope {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::ScopeEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Scope(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ScopeInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ScopeNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ScopeLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ScopeLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ScopeGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ScopeGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ScopeContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ScopeStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ScopeEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ScopeNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetScope(value.0)
      }
    }
  }
  pub mod id_token {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::IdTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::IdToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdTokenNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetIdToken(value.0)
      }
    }
  }
  pub mod session_state {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::SessionStateEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::SessionState(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::SessionStateInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::SessionStateNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::SessionStateLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::SessionStateLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::SessionStateGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::SessionStateGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::SessionStateContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::SessionStateStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::SessionStateEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::SessionStateNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetSessionState(value.0)
      }
    }
  }
  pub mod oauth_token_secret {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::OauthTokenSecretEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::OauthTokenSecret(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OauthTokenSecretInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OauthTokenSecretNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::OauthTokenSecretNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetOauthTokenSecret(value.0)
      }
    }
  }
  pub mod oauth_token {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::OauthTokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::OauthToken(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OauthTokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OauthTokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::OauthTokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::OauthTokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::OauthTokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::OauthTokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::OauthTokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::OauthTokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::OauthTokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::OauthTokenNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetOauthToken(value.0)
      }
    }
  }
  pub mod created_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
  }
  pub mod updated_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UpdatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUpdatedAt(value.0)
      }
    }
  }
  pub mod user {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIs(value)
    }
    pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIsNot(value)
    }
    pub struct Fetch {
      args: user::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::User(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: user::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkUser
    }
    pub struct Link(user::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkUser(value.0)
      }
    }
  }
  pub fn provider_provider_account_id<T: From<UniqueWhereParam>>(
    provider: String,
    provider_account_id: String,
  ) -> T {
    UniqueWhereParam::ProviderProviderAccountIdEquals(provider, provider_account_id).into()
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "id",
      "userId",
      "accountType",
      "provider",
      "providerAccountId",
      "refreshToken",
      "refreshTokenExpiresIn",
      "accessToken",
      "expiresAt",
      "tokenType",
      "scope",
      "idToken",
      "sessionState",
      "oauthTokenSecret",
      "oauthToken",
      "createdAt",
      "updatedAt",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "accountType")]
    pub account_type: String,
    #[serde(rename = "provider")]
    pub provider: String,
    #[serde(rename = "providerAccountId")]
    pub provider_account_id: String,
    #[serde(rename = "refreshToken")]
    pub refresh_token: Option<String>,
    #[serde(rename = "refreshTokenExpiresIn")]
    pub refresh_token_expires_in: Option<i32>,
    #[serde(rename = "accessToken")]
    pub access_token: Option<String>,
    #[serde(rename = "expiresAt")]
    pub expires_at: Option<i32>,
    #[serde(rename = "tokenType")]
    pub token_type: Option<String>,
    #[serde(rename = "scope")]
    pub scope: Option<String>,
    #[serde(rename = "idToken")]
    pub id_token: Option<String>,
    #[serde(rename = "sessionState")]
    pub session_state: Option<String>,
    #[serde(rename = "oauthTokenSecret")]
    pub oauth_token_secret: Option<String>,
    #[serde(rename = "oauthToken")]
    pub oauth_token: Option<String>,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "user")]
    pub user: Option<Box<super::user::Data>>,
  }
  impl Data {
    pub fn user(&self) -> Result<&super::user::Data, &'static str> {
      self
        .user
        .as_ref()
        .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
  }
  pub enum WithParam {
    User(super::user::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::User(args) => {
          let mut selections = super::user::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("user");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetId(String),
    SetUserId(String),
    SetAccountType(String),
    SetProvider(String),
    SetProviderAccountId(String),
    SetRefreshToken(Option<String>),
    SetRefreshTokenExpiresIn(Option<i32>),
    IncrementRefreshTokenExpiresIn(i32),
    DecrementRefreshTokenExpiresIn(i32),
    MultiplyRefreshTokenExpiresIn(i32),
    DivideRefreshTokenExpiresIn(i32),
    SetAccessToken(Option<String>),
    SetExpiresAt(Option<i32>),
    IncrementExpiresAt(i32),
    DecrementExpiresAt(i32),
    MultiplyExpiresAt(i32),
    DivideExpiresAt(i32),
    SetTokenType(Option<String>),
    SetScope(Option<String>),
    SetIdToken(Option<String>),
    SetSessionState(Option<String>),
    SetOauthTokenSecret(Option<String>),
    SetOauthToken(Option<String>),
    SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
    SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
    LinkUser(super::user::UniqueWhereParam),
    UnlinkUser,
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
        SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
        SetParam::SetAccountType(value) => ("accountType".to_string(), PrismaValue::String(value)),
        SetParam::SetProvider(value) => ("provider".to_string(), PrismaValue::String(value)),
        SetParam::SetProviderAccountId(value) => {
          ("providerAccountId".to_string(), PrismaValue::String(value))
        }
        SetParam::SetRefreshToken(value) => {
          (
            "refreshToken".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetRefreshTokenExpiresIn(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            value
              .map(|value| PrismaValue::Int(value as i64))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::IncrementRefreshTokenExpiresIn(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            PrismaValue::Object(vec![(
              "increment".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::DecrementRefreshTokenExpiresIn(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            PrismaValue::Object(vec![(
              "decrement".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::MultiplyRefreshTokenExpiresIn(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            PrismaValue::Object(vec![(
              "multiply".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::DivideRefreshTokenExpiresIn(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            PrismaValue::Object(vec![("divide".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        SetParam::SetAccessToken(value) => {
          (
            "accessToken".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetExpiresAt(value) => {
          (
            "expiresAt".to_string(),
            value
              .map(|value| PrismaValue::Int(value as i64))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::IncrementExpiresAt(value) => {
          (
            "expiresAt".to_string(),
            PrismaValue::Object(vec![(
              "increment".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::DecrementExpiresAt(value) => {
          (
            "expiresAt".to_string(),
            PrismaValue::Object(vec![(
              "decrement".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::MultiplyExpiresAt(value) => {
          (
            "expiresAt".to_string(),
            PrismaValue::Object(vec![(
              "multiply".to_string(),
              PrismaValue::Int(value as i64),
            )]),
          )
        }
        SetParam::DivideExpiresAt(value) => {
          (
            "expiresAt".to_string(),
            PrismaValue::Object(vec![("divide".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        SetParam::SetTokenType(value) => {
          (
            "tokenType".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetScope(value) => {
          (
            "scope".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetIdToken(value) => {
          (
            "idToken".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetSessionState(value) => {
          (
            "sessionState".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetOauthTokenSecret(value) => {
          (
            "oauthTokenSecret".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetOauthToken(value) => {
          (
            "oauthToken".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetCreatedAt(value) => ("createdAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::SetUpdatedAt(value) => ("updatedAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::LinkUser(where_param) => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::UnlinkUser => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
          )
        }
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    UserId(Direction),
    AccountType(Direction),
    Provider(Direction),
    ProviderAccountId(Direction),
    RefreshToken(Direction),
    RefreshTokenExpiresIn(Direction),
    AccessToken(Direction),
    ExpiresAt(Direction),
    TokenType(Direction),
    Scope(Direction),
    IdToken(Direction),
    SessionState(Direction),
    OauthTokenSecret(Direction),
    OauthToken(Direction),
    CreatedAt(Direction),
    UpdatedAt(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(direction) => ("id".to_string(), PrismaValue::String(direction.to_string())),
        Self::UserId(direction) => {
          (
            "userId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::AccountType(direction) => {
          (
            "accountType".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Provider(direction) => {
          (
            "provider".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::ProviderAccountId(direction) => {
          (
            "providerAccountId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::RefreshToken(direction) => {
          (
            "refreshToken".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::RefreshTokenExpiresIn(direction) => {
          (
            "refreshTokenExpiresIn".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::AccessToken(direction) => {
          (
            "accessToken".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::ExpiresAt(direction) => {
          (
            "expiresAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::TokenType(direction) => {
          (
            "tokenType".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Scope(direction) => {
          (
            "scope".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::IdToken(direction) => {
          (
            "idToken".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::SessionState(direction) => {
          (
            "sessionState".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::OauthTokenSecret(direction) => {
          (
            "oauthTokenSecret".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::OauthToken(direction) => {
          (
            "oauthToken".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::CreatedAt(direction) => {
          (
            "createdAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UpdatedAt(direction) => {
          (
            "updatedAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Id(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    ProviderProviderAccountIdEquals(String, String),
    IdEquals(String),
    IdInVec(Vec<String>),
    IdNotInVec(Vec<String>),
    IdLt(String),
    IdLte(String),
    IdGt(String),
    IdGte(String),
    IdContains(String),
    IdStartsWith(String),
    IdEndsWith(String),
    IdNot(String),
    UserIdEquals(String),
    UserIdInVec(Vec<String>),
    UserIdNotInVec(Vec<String>),
    UserIdLt(String),
    UserIdLte(String),
    UserIdGt(String),
    UserIdGte(String),
    UserIdContains(String),
    UserIdStartsWith(String),
    UserIdEndsWith(String),
    UserIdNot(String),
    AccountTypeEquals(String),
    AccountTypeInVec(Vec<String>),
    AccountTypeNotInVec(Vec<String>),
    AccountTypeLt(String),
    AccountTypeLte(String),
    AccountTypeGt(String),
    AccountTypeGte(String),
    AccountTypeContains(String),
    AccountTypeStartsWith(String),
    AccountTypeEndsWith(String),
    AccountTypeNot(String),
    ProviderEquals(String),
    ProviderInVec(Vec<String>),
    ProviderNotInVec(Vec<String>),
    ProviderLt(String),
    ProviderLte(String),
    ProviderGt(String),
    ProviderGte(String),
    ProviderContains(String),
    ProviderStartsWith(String),
    ProviderEndsWith(String),
    ProviderNot(String),
    ProviderAccountIdEquals(String),
    ProviderAccountIdInVec(Vec<String>),
    ProviderAccountIdNotInVec(Vec<String>),
    ProviderAccountIdLt(String),
    ProviderAccountIdLte(String),
    ProviderAccountIdGt(String),
    ProviderAccountIdGte(String),
    ProviderAccountIdContains(String),
    ProviderAccountIdStartsWith(String),
    ProviderAccountIdEndsWith(String),
    ProviderAccountIdNot(String),
    RefreshTokenEquals(Option<String>),
    RefreshTokenInVec(Vec<String>),
    RefreshTokenNotInVec(Vec<String>),
    RefreshTokenLt(String),
    RefreshTokenLte(String),
    RefreshTokenGt(String),
    RefreshTokenGte(String),
    RefreshTokenContains(String),
    RefreshTokenStartsWith(String),
    RefreshTokenEndsWith(String),
    RefreshTokenNot(String),
    RefreshTokenExpiresInEquals(Option<i32>),
    RefreshTokenExpiresInInVec(Vec<i32>),
    RefreshTokenExpiresInNotInVec(Vec<i32>),
    RefreshTokenExpiresInLt(i32),
    RefreshTokenExpiresInLte(i32),
    RefreshTokenExpiresInGt(i32),
    RefreshTokenExpiresInGte(i32),
    RefreshTokenExpiresInNot(i32),
    AccessTokenEquals(Option<String>),
    AccessTokenInVec(Vec<String>),
    AccessTokenNotInVec(Vec<String>),
    AccessTokenLt(String),
    AccessTokenLte(String),
    AccessTokenGt(String),
    AccessTokenGte(String),
    AccessTokenContains(String),
    AccessTokenStartsWith(String),
    AccessTokenEndsWith(String),
    AccessTokenNot(String),
    ExpiresAtEquals(Option<i32>),
    ExpiresAtInVec(Vec<i32>),
    ExpiresAtNotInVec(Vec<i32>),
    ExpiresAtLt(i32),
    ExpiresAtLte(i32),
    ExpiresAtGt(i32),
    ExpiresAtGte(i32),
    ExpiresAtNot(i32),
    TokenTypeEquals(Option<String>),
    TokenTypeInVec(Vec<String>),
    TokenTypeNotInVec(Vec<String>),
    TokenTypeLt(String),
    TokenTypeLte(String),
    TokenTypeGt(String),
    TokenTypeGte(String),
    TokenTypeContains(String),
    TokenTypeStartsWith(String),
    TokenTypeEndsWith(String),
    TokenTypeNot(String),
    ScopeEquals(Option<String>),
    ScopeInVec(Vec<String>),
    ScopeNotInVec(Vec<String>),
    ScopeLt(String),
    ScopeLte(String),
    ScopeGt(String),
    ScopeGte(String),
    ScopeContains(String),
    ScopeStartsWith(String),
    ScopeEndsWith(String),
    ScopeNot(String),
    IdTokenEquals(Option<String>),
    IdTokenInVec(Vec<String>),
    IdTokenNotInVec(Vec<String>),
    IdTokenLt(String),
    IdTokenLte(String),
    IdTokenGt(String),
    IdTokenGte(String),
    IdTokenContains(String),
    IdTokenStartsWith(String),
    IdTokenEndsWith(String),
    IdTokenNot(String),
    SessionStateEquals(Option<String>),
    SessionStateInVec(Vec<String>),
    SessionStateNotInVec(Vec<String>),
    SessionStateLt(String),
    SessionStateLte(String),
    SessionStateGt(String),
    SessionStateGte(String),
    SessionStateContains(String),
    SessionStateStartsWith(String),
    SessionStateEndsWith(String),
    SessionStateNot(String),
    OauthTokenSecretEquals(Option<String>),
    OauthTokenSecretInVec(Vec<String>),
    OauthTokenSecretNotInVec(Vec<String>),
    OauthTokenSecretLt(String),
    OauthTokenSecretLte(String),
    OauthTokenSecretGt(String),
    OauthTokenSecretGte(String),
    OauthTokenSecretContains(String),
    OauthTokenSecretStartsWith(String),
    OauthTokenSecretEndsWith(String),
    OauthTokenSecretNot(String),
    OauthTokenEquals(Option<String>),
    OauthTokenInVec(Vec<String>),
    OauthTokenNotInVec(Vec<String>),
    OauthTokenLt(String),
    OauthTokenLte(String),
    OauthTokenGt(String),
    OauthTokenGte(String),
    OauthTokenContains(String),
    OauthTokenStartsWith(String),
    OauthTokenEndsWith(String),
    OauthTokenNot(String),
    CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UserIs(Vec<super::user::WhereParam>),
    UserIsNot(Vec<super::user::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::ProviderProviderAccountIdEquals(provider, provider_account_id) => {
          (
            "provider_providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![
              ("provider".to_string(), PrismaValue::String(provider)),
              (
                "providerAccountId".to_string(),
                PrismaValue::String(provider_account_id),
              ),
            ]),
          )
        }
        Self::IdEquals(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdNotInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdLt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdLte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdContains(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdStartsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdEndsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdNot(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdEquals(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdNotInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdLt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdLte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdContains(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdStartsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdEndsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdNot(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeEquals(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeInVec(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::AccountTypeNotInVec(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::AccountTypeLt(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeLte(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeGt(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeGte(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccountTypeContains(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccountTypeStartsWith(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccountTypeEndsWith(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccountTypeNot(value) => {
          (
            "accountType".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderEquals(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderInVec(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProviderNotInVec(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProviderLt(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderLte(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderGt(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderGte(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderContains(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderStartsWith(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderEndsWith(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderNot(value) => {
          (
            "provider".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdEquals(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdInVec(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProviderAccountIdNotInVec(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProviderAccountIdLt(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdLte(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdGt(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdGte(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProviderAccountIdContains(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderAccountIdStartsWith(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderAccountIdEndsWith(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProviderAccountIdNot(value) => {
          (
            "providerAccountId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenEquals(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::RefreshTokenInVec(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::RefreshTokenNotInVec(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::RefreshTokenLt(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenLte(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenGt(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenGte(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenContains(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::RefreshTokenStartsWith(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::RefreshTokenEndsWith(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::RefreshTokenNot(value) => {
          (
            "refreshToken".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::RefreshTokenExpiresInEquals(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::Int(value as i64))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::RefreshTokenExpiresInInVec(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::Int(v as i64))
                  .collect(),
              ),
            )]),
          )
        }
        Self::RefreshTokenExpiresInNotInVec(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::Int(v as i64))
                  .collect(),
              ),
            )]),
          )
        }
        Self::RefreshTokenExpiresInLt(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::RefreshTokenExpiresInLte(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::RefreshTokenExpiresInGt(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::RefreshTokenExpiresInGte(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::RefreshTokenExpiresInNot(value) => {
          (
            "refreshTokenExpiresIn".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::AccessTokenEquals(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::AccessTokenInVec(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::AccessTokenNotInVec(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::AccessTokenLt(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccessTokenLte(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccessTokenGt(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccessTokenGte(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::AccessTokenContains(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccessTokenStartsWith(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccessTokenEndsWith(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::AccessTokenNot(value) => {
          (
            "accessToken".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ExpiresAtEquals(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::Int(value as i64))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::ExpiresAtInVec(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::Int(v as i64))
                  .collect(),
              ),
            )]),
          )
        }
        Self::ExpiresAtNotInVec(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::Int(v as i64))
                  .collect(),
              ),
            )]),
          )
        }
        Self::ExpiresAtLt(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::ExpiresAtLte(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::ExpiresAtGt(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::ExpiresAtGte(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::ExpiresAtNot(value) => {
          (
            "expiresAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::Int(value as i64))]),
          )
        }
        Self::TokenTypeEquals(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::TokenTypeInVec(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TokenTypeNotInVec(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TokenTypeLt(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenTypeLte(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenTypeGt(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenTypeGte(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenTypeContains(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenTypeStartsWith(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenTypeEndsWith(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenTypeNot(value) => {
          (
            "tokenType".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ScopeEquals(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::ScopeInVec(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ScopeNotInVec(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ScopeLt(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ScopeLte(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ScopeGt(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ScopeGte(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ScopeContains(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ScopeStartsWith(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ScopeEndsWith(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ScopeNot(value) => {
          (
            "scope".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdTokenEquals(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::IdTokenInVec(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdTokenNotInVec(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdTokenLt(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdTokenLte(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdTokenGt(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdTokenGte(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdTokenContains(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdTokenStartsWith(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdTokenEndsWith(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdTokenNot(value) => {
          (
            "idToken".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::SessionStateEquals(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::SessionStateInVec(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::SessionStateNotInVec(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::SessionStateLt(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::SessionStateLte(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::SessionStateGt(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::SessionStateGte(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::SessionStateContains(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::SessionStateStartsWith(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::SessionStateEndsWith(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::SessionStateNot(value) => {
          (
            "sessionState".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenSecretEquals(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::OauthTokenSecretInVec(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OauthTokenSecretNotInVec(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OauthTokenSecretLt(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenSecretLte(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenSecretGt(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenSecretGte(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenSecretContains(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenSecretStartsWith(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenSecretEndsWith(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenSecretNot(value) => {
          (
            "oauthTokenSecret".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenEquals(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::OauthTokenInVec(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OauthTokenNotInVec(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OauthTokenLt(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenLte(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenGt(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenGte(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OauthTokenContains(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenStartsWith(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenEndsWith(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OauthTokenNot(value) => {
          (
            "oauthToken".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::CreatedAtEquals(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::CreatedAtInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtNotInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtLt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtLte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtNot(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtEquals(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::UpdatedAtInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtNotInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtLt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtLte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtNot(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UserIs(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIsNot(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    ProviderProviderAccountIdEquals(String, String),
    IdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::ProviderProviderAccountIdEquals(provider, provider_account_id) => {
          Self::ProviderProviderAccountIdEquals(provider, provider_account_id)
        }
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      account_type: account_type::Set,
      provider: provider::Set,
      provider_account_id: provider_account_id::Set,
      user: user::Link,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(account_type.into());
      _params.push(provider.into());
      _params.push(provider_account_id.into());
      _params.push(user.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (
        account_type::Set,
        provider::Set,
        provider_account_id::Set,
        user::Link,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (account_type, provider, provider_account_id, user, mut _params) = _create;
      _params.push(account_type.into());
      _params.push(provider.into());
      _params.push(provider_account_id.into());
      _params.push(user.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Account", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod user {
  use super::{_prisma::*, *};
  pub mod id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod name {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
  }
  pub mod primary_email {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::PrimaryEmailEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::PrimaryEmail(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PrimaryEmailInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PrimaryEmailNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::PrimaryEmailLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::PrimaryEmailLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::PrimaryEmailGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::PrimaryEmailGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::PrimaryEmailContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::PrimaryEmailStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::PrimaryEmailEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::PrimaryEmailNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPrimaryEmail(value.0)
      }
    }
  }
  pub mod emails {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn some(value: Vec<email::WhereParam>) -> WhereParam {
      WhereParam::EmailsSome(value)
    }
    pub fn every(value: Vec<email::WhereParam>) -> WhereParam {
      WhereParam::EmailsEvery(value)
    }
    pub fn none(value: Vec<email::WhereParam>) -> WhereParam {
      WhereParam::EmailsNone(value)
    }
    pub struct Fetch {
      args: email::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<email::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }

      pub fn order_by(mut self, param: email::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }

      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }

      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }

      pub fn cursor(mut self, value: impl Into<email::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Emails(fetch.args)
      }
    }
    pub fn fetch(params: Vec<email::WhereParam>) -> Fetch {
      Fetch {
        args: email::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<email::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<email::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkEmails(params)
    }
    pub struct Link(Vec<email::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkEmails(value.0)
      }
    }
  }
  pub mod image {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::ImageEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Image(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ImageInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ImageNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ImageLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ImageLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ImageGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ImageGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ImageContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ImageStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ImageEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ImageNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetImage(value.0)
      }
    }
  }
  pub mod password {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<password::WhereParam>) -> WhereParam {
      WhereParam::PasswordIs(value)
    }
    pub fn is_not(value: Vec<password::WhereParam>) -> WhereParam {
      WhereParam::PasswordIsNot(value)
    }
    pub struct Fetch {
      args: password::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<password::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Password(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: password::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: password::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub struct Link(password::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkPassword(value.0)
      }
    }
  }
  pub mod accounts {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn some(value: Vec<account::WhereParam>) -> WhereParam {
      WhereParam::AccountsSome(value)
    }
    pub fn every(value: Vec<account::WhereParam>) -> WhereParam {
      WhereParam::AccountsEvery(value)
    }
    pub fn none(value: Vec<account::WhereParam>) -> WhereParam {
      WhereParam::AccountsNone(value)
    }
    pub struct Fetch {
      args: account::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<account::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }

      pub fn order_by(mut self, param: account::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }

      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }

      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }

      pub fn cursor(mut self, value: impl Into<account::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Accounts(fetch.args)
      }
    }
    pub fn fetch(params: Vec<account::WhereParam>) -> Fetch {
      Fetch {
        args: account::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<account::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<account::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkAccounts(params)
    }
    pub struct Link(Vec<account::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkAccounts(value.0)
      }
    }
  }
  pub mod wallets {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn some(value: Vec<user_wallet::WhereParam>) -> WhereParam {
      WhereParam::WalletsSome(value)
    }
    pub fn every(value: Vec<user_wallet::WhereParam>) -> WhereParam {
      WhereParam::WalletsEvery(value)
    }
    pub fn none(value: Vec<user_wallet::WhereParam>) -> WhereParam {
      WhereParam::WalletsNone(value)
    }
    pub struct Fetch {
      args: user_wallet::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user_wallet::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }

      pub fn order_by(mut self, param: user_wallet::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }

      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }

      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }

      pub fn cursor(mut self, value: impl Into<user_wallet::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Wallets(fetch.args)
      }
    }
    pub fn fetch(params: Vec<user_wallet::WhereParam>) -> Fetch {
      Fetch {
        args: user_wallet::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<user_wallet::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<user_wallet::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkWallets(params)
    }
    pub struct Link(Vec<user_wallet::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkWallets(value.0)
      }
    }
  }
  pub mod projects {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn some(value: Vec<project::WhereParam>) -> WhereParam {
      WhereParam::ProjectsSome(value)
    }
    pub fn every(value: Vec<project::WhereParam>) -> WhereParam {
      WhereParam::ProjectsEvery(value)
    }
    pub fn none(value: Vec<project::WhereParam>) -> WhereParam {
      WhereParam::ProjectsNone(value)
    }
    pub struct Fetch {
      args: project::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<project::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }

      pub fn order_by(mut self, param: project::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }

      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }

      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }

      pub fn cursor(mut self, value: impl Into<project::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Projects(fetch.args)
      }
    }
    pub fn fetch(params: Vec<project::WhereParam>) -> Fetch {
      Fetch {
        args: project::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<project::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<project::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkProjects(params)
    }
    pub struct Link(Vec<project::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkProjects(value.0)
      }
    }
  }
  pub mod created_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
  }
  pub mod updated_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UpdatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUpdatedAt(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "id",
      "name",
      "primaryEmail",
      "image",
      "createdAt",
      "updatedAt",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "name")]
    pub name: Option<String>,
    #[serde(rename = "primaryEmail")]
    pub primary_email: Option<String>,
    #[serde(rename = "emails")]
    pub emails: Option<Vec<super::email::Data>>,
    #[serde(rename = "image")]
    pub image: Option<String>,
    #[serde(
      rename = "password",
      default,
      skip_serializing_if = "Option::is_none",
      with = "prisma_client_rust::serde::double_option"
    )]
    pub password: Option<Option<Box<super::password::Data>>>,
    #[serde(rename = "accounts")]
    pub accounts: Option<Vec<super::account::Data>>,
    #[serde(rename = "wallets")]
    pub wallets: Option<Vec<super::user_wallet::Data>>,
    #[serde(rename = "projects")]
    pub projects: Option<Vec<super::project::Data>>,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime<chrono::FixedOffset>,
  }
  impl Data {
    pub fn emails(&self) -> Result<&Vec<super::email::Data>, &'static str> {
      self
        .emails
        .as_ref()
        .ok_or("Attempted to access 'emails' but did not fetch it using the .with() syntax")
    }

    pub fn password(&self) -> Result<Option<&super::password::Data>, &'static str> {
      self
        .password
        .as_ref()
        .ok_or("Attempted to access 'password' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref().map(|v| v.as_ref()))
    }

    pub fn accounts(&self) -> Result<&Vec<super::account::Data>, &'static str> {
      self
        .accounts
        .as_ref()
        .ok_or("Attempted to access 'accounts' but did not fetch it using the .with() syntax")
    }

    pub fn wallets(&self) -> Result<&Vec<super::user_wallet::Data>, &'static str> {
      self
        .wallets
        .as_ref()
        .ok_or("Attempted to access 'wallets' but did not fetch it using the .with() syntax")
    }

    pub fn projects(&self) -> Result<&Vec<super::project::Data>, &'static str> {
      self
        .projects
        .as_ref()
        .ok_or("Attempted to access 'projects' but did not fetch it using the .with() syntax")
    }
  }
  pub enum WithParam {
    Emails(super::email::ManyArgs),
    Password(super::password::UniqueArgs),
    Accounts(super::account::ManyArgs),
    Wallets(super::user_wallet::ManyArgs),
    Projects(super::project::ManyArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::Emails(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::email::_outputs());
          let mut builder = Selection::builder("emails");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
        Self::Password(args) => {
          let mut selections = super::password::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("password");
          builder.nested_selections(selections);
          builder.build()
        }
        Self::Accounts(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::account::_outputs());
          let mut builder = Selection::builder("accounts");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
        Self::Wallets(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::user_wallet::_outputs());
          let mut builder = Selection::builder("wallets");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
        Self::Projects(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::project::_outputs());
          let mut builder = Selection::builder("projects");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetId(String),
    SetName(Option<String>),
    SetPrimaryEmail(Option<String>),
    LinkEmails(Vec<super::email::UniqueWhereParam>),
    UnlinkEmails(Vec<super::email::UniqueWhereParam>),
    SetImage(Option<String>),
    LinkPassword(super::password::UniqueWhereParam),
    LinkAccounts(Vec<super::account::UniqueWhereParam>),
    UnlinkAccounts(Vec<super::account::UniqueWhereParam>),
    LinkWallets(Vec<super::user_wallet::UniqueWhereParam>),
    UnlinkWallets(Vec<super::user_wallet::UniqueWhereParam>),
    LinkProjects(Vec<super::project::UniqueWhereParam>),
    UnlinkProjects(Vec<super::project::UniqueWhereParam>),
    SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
    SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
        SetParam::SetName(value) => {
          (
            "name".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetPrimaryEmail(value) => {
          (
            "primaryEmail".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::LinkEmails(where_params) => {
          (
            "emails".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::email::WhereParam>::into),
              )),
            )]),
          )
        }
        SetParam::UnlinkEmails(where_params) => {
          (
            "emails".to_string(),
            PrismaValue::Object(vec![(
              "disconnect".to_string(),
              PrismaValue::Object(
                transform_equals(
                  where_params
                    .into_iter()
                    .map(Into::<super::email::WhereParam>::into),
                )
                .into_iter()
                .collect(),
              ),
            )]),
          )
        }
        SetParam::SetImage(value) => {
          (
            "image".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::LinkPassword(where_param) => {
          (
            "password".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::password::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::LinkAccounts(where_params) => {
          (
            "accounts".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::account::WhereParam>::into),
              )),
            )]),
          )
        }
        SetParam::UnlinkAccounts(where_params) => {
          (
            "accounts".to_string(),
            PrismaValue::Object(vec![(
              "disconnect".to_string(),
              PrismaValue::Object(
                transform_equals(
                  where_params
                    .into_iter()
                    .map(Into::<super::account::WhereParam>::into),
                )
                .into_iter()
                .collect(),
              ),
            )]),
          )
        }
        SetParam::LinkWallets(where_params) => {
          (
            "wallets".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::user_wallet::WhereParam>::into),
              )),
            )]),
          )
        }
        SetParam::UnlinkWallets(where_params) => {
          (
            "wallets".to_string(),
            PrismaValue::Object(vec![(
              "disconnect".to_string(),
              PrismaValue::Object(
                transform_equals(
                  where_params
                    .into_iter()
                    .map(Into::<super::user_wallet::WhereParam>::into),
                )
                .into_iter()
                .collect(),
              ),
            )]),
          )
        }
        SetParam::LinkProjects(where_params) => {
          (
            "projects".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::project::WhereParam>::into),
              )),
            )]),
          )
        }
        SetParam::UnlinkProjects(where_params) => {
          (
            "projects".to_string(),
            PrismaValue::Object(vec![(
              "disconnect".to_string(),
              PrismaValue::Object(
                transform_equals(
                  where_params
                    .into_iter()
                    .map(Into::<super::project::WhereParam>::into),
                )
                .into_iter()
                .collect(),
              ),
            )]),
          )
        }
        SetParam::SetCreatedAt(value) => ("createdAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::SetUpdatedAt(value) => ("updatedAt".to_string(), PrismaValue::DateTime(value)),
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    Name(Direction),
    PrimaryEmail(Direction),
    Image(Direction),
    CreatedAt(Direction),
    UpdatedAt(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(direction) => ("id".to_string(), PrismaValue::String(direction.to_string())),
        Self::Name(direction) => {
          (
            "name".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::PrimaryEmail(direction) => {
          (
            "primaryEmail".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Image(direction) => {
          (
            "image".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::CreatedAt(direction) => {
          (
            "createdAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UpdatedAt(direction) => {
          (
            "updatedAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Id(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(String),
    IdInVec(Vec<String>),
    IdNotInVec(Vec<String>),
    IdLt(String),
    IdLte(String),
    IdGt(String),
    IdGte(String),
    IdContains(String),
    IdStartsWith(String),
    IdEndsWith(String),
    IdNot(String),
    NameEquals(Option<String>),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameNot(String),
    PrimaryEmailEquals(Option<String>),
    PrimaryEmailInVec(Vec<String>),
    PrimaryEmailNotInVec(Vec<String>),
    PrimaryEmailLt(String),
    PrimaryEmailLte(String),
    PrimaryEmailGt(String),
    PrimaryEmailGte(String),
    PrimaryEmailContains(String),
    PrimaryEmailStartsWith(String),
    PrimaryEmailEndsWith(String),
    PrimaryEmailNot(String),
    EmailsSome(Vec<super::email::WhereParam>),
    EmailsEvery(Vec<super::email::WhereParam>),
    EmailsNone(Vec<super::email::WhereParam>),
    ImageEquals(Option<String>),
    ImageInVec(Vec<String>),
    ImageNotInVec(Vec<String>),
    ImageLt(String),
    ImageLte(String),
    ImageGt(String),
    ImageGte(String),
    ImageContains(String),
    ImageStartsWith(String),
    ImageEndsWith(String),
    ImageNot(String),
    PasswordIs(Vec<super::password::WhereParam>),
    PasswordIsNot(Vec<super::password::WhereParam>),
    AccountsSome(Vec<super::account::WhereParam>),
    AccountsEvery(Vec<super::account::WhereParam>),
    AccountsNone(Vec<super::account::WhereParam>),
    WalletsSome(Vec<super::user_wallet::WhereParam>),
    WalletsEvery(Vec<super::user_wallet::WhereParam>),
    WalletsNone(Vec<super::user_wallet::WhereParam>),
    ProjectsSome(Vec<super::project::WhereParam>),
    ProjectsEvery(Vec<super::project::WhereParam>),
    ProjectsNone(Vec<super::project::WhereParam>),
    CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::IdEquals(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdNotInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdLt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdLte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdContains(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdStartsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdEndsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdNot(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameEquals(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::NameInVec(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::NameNotInVec(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::NameLt(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameLte(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameGt(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameGte(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameContains(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameStartsWith(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameEndsWith(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameNot(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PrimaryEmailEquals(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::PrimaryEmailInVec(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::PrimaryEmailNotInVec(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::PrimaryEmailLt(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PrimaryEmailLte(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PrimaryEmailGt(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PrimaryEmailGte(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PrimaryEmailContains(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PrimaryEmailStartsWith(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PrimaryEmailEndsWith(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PrimaryEmailNot(value) => {
          (
            "primaryEmail".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailsSome(value) => {
          (
            "emails".to_string(),
            SerializedWhereValue::Object(vec![(
              "some".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::EmailsEvery(value) => {
          (
            "emails".to_string(),
            SerializedWhereValue::Object(vec![(
              "every".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::EmailsNone(value) => {
          (
            "emails".to_string(),
            SerializedWhereValue::Object(vec![(
              "none".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ImageEquals(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::ImageInVec(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ImageNotInVec(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ImageLt(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ImageLte(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ImageGt(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ImageGte(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ImageContains(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ImageStartsWith(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ImageEndsWith(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ImageNot(value) => {
          (
            "image".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PasswordIs(value) => {
          (
            "password".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::PasswordIsNot(value) => {
          (
            "password".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::AccountsSome(value) => {
          (
            "accounts".to_string(),
            SerializedWhereValue::Object(vec![(
              "some".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::AccountsEvery(value) => {
          (
            "accounts".to_string(),
            SerializedWhereValue::Object(vec![(
              "every".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::AccountsNone(value) => {
          (
            "accounts".to_string(),
            SerializedWhereValue::Object(vec![(
              "none".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::WalletsSome(value) => {
          (
            "wallets".to_string(),
            SerializedWhereValue::Object(vec![(
              "some".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::WalletsEvery(value) => {
          (
            "wallets".to_string(),
            SerializedWhereValue::Object(vec![(
              "every".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::WalletsNone(value) => {
          (
            "wallets".to_string(),
            SerializedWhereValue::Object(vec![(
              "none".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ProjectsSome(value) => {
          (
            "projects".to_string(),
            SerializedWhereValue::Object(vec![(
              "some".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ProjectsEvery(value) => {
          (
            "projects".to_string(),
            SerializedWhereValue::Object(vec![(
              "every".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ProjectsNone(value) => {
          (
            "projects".to_string(),
            SerializedWhereValue::Object(vec![(
              "none".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::CreatedAtEquals(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::CreatedAtInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtNotInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtLt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtLte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtNot(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtEquals(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::UpdatedAtInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtNotInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtLt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtLte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtNot(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    IdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(&self, mut _params: Vec<SetParam>) -> Create {
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("User", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("User", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("User", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("User", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (mut _params) = _create;
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("User", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod email {
  use super::{_prisma::*, *};
  pub mod email {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals<A, T: prisma_client_rust::traits::FromOptionalUniqueArg<Set, Arg = A>>(
      value: A,
    ) -> T {
      T::from_arg(value)
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Email(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Email(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::EmailInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::EmailNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::EmailLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::EmailLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::EmailGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::EmailGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::EmailContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::EmailStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::EmailEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::EmailNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetEmail(value.0)
      }
    }
  }
  pub mod email_verified {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::EmailVerifiedEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::EmailVerified(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::EmailVerifiedInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::EmailVerifiedNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::EmailVerifiedLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::EmailVerifiedLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::EmailVerifiedGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::EmailVerifiedGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::EmailVerifiedNot(value)
    }
    pub struct Set(Option<chrono::DateTime<chrono::FixedOffset>>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetEmailVerified(value.0)
      }
    }
  }
  pub mod user_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::UserIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UserId(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::UserId(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UserIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UserIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UserIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UserIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UserIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UserIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UserIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UserIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUserId(value.0)
      }
    }
  }
  pub mod created_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
  }
  pub mod user {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIs(value)
    }
    pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIsNot(value)
    }
    pub struct Fetch {
      args: user::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::User(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: user::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkUser
    }
    pub struct Link(user::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkUser(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    ["email", "emailVerified", "userId", "createdAt"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "email")]
    pub email: Option<String>,
    #[serde(rename = "emailVerified")]
    pub email_verified: Option<chrono::DateTime<chrono::FixedOffset>>,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "user")]
    pub user: Option<Box<super::user::Data>>,
  }
  impl Data {
    pub fn user(&self) -> Result<&super::user::Data, &'static str> {
      self
        .user
        .as_ref()
        .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
  }
  pub enum WithParam {
    User(super::user::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::User(args) => {
          let mut selections = super::user::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("user");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetEmail(Option<String>),
    SetEmailVerified(Option<chrono::DateTime<chrono::FixedOffset>>),
    SetUserId(String),
    SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
    LinkUser(super::user::UniqueWhereParam),
    UnlinkUser,
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetEmail(value) => {
          (
            "email".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetEmailVerified(value) => {
          (
            "emailVerified".to_string(),
            value
              .map(|value| PrismaValue::DateTime(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
        SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
        SetParam::SetCreatedAt(value) => ("createdAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::LinkUser(where_param) => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::UnlinkUser => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
          )
        }
      }
    }
  }
  pub enum OrderByParam {
    Email(Direction),
    EmailVerified(Direction),
    UserId(Direction),
    CreatedAt(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Email(direction) => {
          (
            "email".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::EmailVerified(direction) => {
          (
            "emailVerified".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UserId(direction) => {
          (
            "userId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::CreatedAt(direction) => {
          (
            "createdAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Email(String),
    UserId(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Email(cursor) => ("email".to_string(), PrismaValue::String(cursor)),
        Self::UserId(cursor) => ("userId".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    EmailEquals(Option<String>),
    EmailInVec(Vec<String>),
    EmailNotInVec(Vec<String>),
    EmailLt(String),
    EmailLte(String),
    EmailGt(String),
    EmailGte(String),
    EmailContains(String),
    EmailStartsWith(String),
    EmailEndsWith(String),
    EmailNot(String),
    EmailVerifiedEquals(Option<chrono::DateTime<chrono::FixedOffset>>),
    EmailVerifiedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    EmailVerifiedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    EmailVerifiedLt(chrono::DateTime<chrono::FixedOffset>),
    EmailVerifiedLte(chrono::DateTime<chrono::FixedOffset>),
    EmailVerifiedGt(chrono::DateTime<chrono::FixedOffset>),
    EmailVerifiedGte(chrono::DateTime<chrono::FixedOffset>),
    EmailVerifiedNot(chrono::DateTime<chrono::FixedOffset>),
    UserIdEquals(String),
    UserIdInVec(Vec<String>),
    UserIdNotInVec(Vec<String>),
    UserIdLt(String),
    UserIdLte(String),
    UserIdGt(String),
    UserIdGte(String),
    UserIdContains(String),
    UserIdStartsWith(String),
    UserIdEndsWith(String),
    UserIdNot(String),
    CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UserIs(Vec<super::user::WhereParam>),
    UserIsNot(Vec<super::user::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::EmailEquals(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::EmailInVec(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::EmailNotInVec(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::EmailLt(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailLte(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailGt(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailGte(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailContains(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::EmailStartsWith(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::EmailEndsWith(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::EmailNot(value) => {
          (
            "email".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::EmailVerifiedEquals(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::DateTime(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::EmailVerifiedInVec(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::EmailVerifiedNotInVec(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::EmailVerifiedLt(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::EmailVerifiedLte(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::EmailVerifiedGt(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::EmailVerifiedGte(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::EmailVerifiedNot(value) => {
          (
            "emailVerified".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UserIdEquals(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdNotInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdLt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdLte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdContains(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdStartsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdEndsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdNot(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::CreatedAtEquals(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::CreatedAtInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtNotInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtLt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtLte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtNot(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UserIs(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIsNot(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    EmailEquals(String),
    UserIdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(Some(value)),
        UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
      }
    }
  }
  impl prisma_client_rust::traits::FromOptionalUniqueArg<email::Set> for WhereParam {
    type Arg = Option<String>;

    fn from_arg(arg: Self::Arg) -> Self
    where
      Self: Sized,
    {
      Self::EmailEquals(arg)
    }
  }
  impl prisma_client_rust::traits::FromOptionalUniqueArg<email::Set> for UniqueWhereParam {
    type Arg = String;

    fn from_arg(arg: Self::Arg) -> Self
    where
      Self: Sized,
    {
      Self::EmailEquals(arg)
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(&self, user: user::Link, mut _params: Vec<SetParam>) -> Create {
      _params.push(user.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Email", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Email", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Email", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Email", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (user::Link, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (user, mut _params) = _create;
      _params.push(user.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Email", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod verification_token {
  use super::{_prisma::*, *};
  pub mod identifier {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::IdentifierEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Identifier(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdentifierInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdentifierNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdentifierLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdentifierLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdentifierGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdentifierGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdentifierContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdentifierStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdentifierEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdentifierNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetIdentifier(value.0)
      }
    }
  }
  pub mod token {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::TokenEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Token(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Token(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TokenInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TokenNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::TokenLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::TokenLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::TokenGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::TokenGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::TokenContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::TokenStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::TokenEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::TokenNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetToken(value.0)
      }
    }
  }
  pub mod expires {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Expires(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::ExpiresInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::ExpiresNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::ExpiresNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetExpires(value.0)
      }
    }
  }
  pub fn identifier_token<T: From<UniqueWhereParam>>(identifier: String, token: String) -> T {
    UniqueWhereParam::IdentifierTokenEquals(identifier, token).into()
  }
  pub fn _outputs() -> Vec<Selection> {
    ["identifier", "token", "expires"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "identifier")]
    pub identifier: String,
    #[serde(rename = "token")]
    pub token: String,
    #[serde(rename = "expires")]
    pub expires: chrono::DateTime<chrono::FixedOffset>,
  }
  impl Data {}
  pub enum WithParam {}
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {}
    }
  }
  pub enum SetParam {
    SetIdentifier(String),
    SetToken(String),
    SetExpires(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetIdentifier(value) => ("identifier".to_string(), PrismaValue::String(value)),
        SetParam::SetToken(value) => ("token".to_string(), PrismaValue::String(value)),
        SetParam::SetExpires(value) => ("expires".to_string(), PrismaValue::DateTime(value)),
      }
    }
  }
  pub enum OrderByParam {
    Identifier(Direction),
    Token(Direction),
    Expires(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Identifier(direction) => {
          (
            "identifier".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Token(direction) => {
          (
            "token".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Expires(direction) => {
          (
            "expires".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Token(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Token(cursor) => ("token".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdentifierTokenEquals(String, String),
    IdentifierEquals(String),
    IdentifierInVec(Vec<String>),
    IdentifierNotInVec(Vec<String>),
    IdentifierLt(String),
    IdentifierLte(String),
    IdentifierGt(String),
    IdentifierGte(String),
    IdentifierContains(String),
    IdentifierStartsWith(String),
    IdentifierEndsWith(String),
    IdentifierNot(String),
    TokenEquals(String),
    TokenInVec(Vec<String>),
    TokenNotInVec(Vec<String>),
    TokenLt(String),
    TokenLte(String),
    TokenGt(String),
    TokenGte(String),
    TokenContains(String),
    TokenStartsWith(String),
    TokenEndsWith(String),
    TokenNot(String),
    ExpiresEquals(chrono::DateTime<chrono::FixedOffset>),
    ExpiresInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    ExpiresNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    ExpiresLt(chrono::DateTime<chrono::FixedOffset>),
    ExpiresLte(chrono::DateTime<chrono::FixedOffset>),
    ExpiresGt(chrono::DateTime<chrono::FixedOffset>),
    ExpiresGte(chrono::DateTime<chrono::FixedOffset>),
    ExpiresNot(chrono::DateTime<chrono::FixedOffset>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::IdentifierTokenEquals(identifier, token) => {
          (
            "identifier_token".to_string(),
            SerializedWhereValue::Object(vec![
              ("identifier".to_string(), PrismaValue::String(identifier)),
              ("token".to_string(), PrismaValue::String(token)),
            ]),
          )
        }
        Self::IdentifierEquals(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdentifierInVec(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdentifierNotInVec(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdentifierLt(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdentifierLte(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdentifierGt(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdentifierGte(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdentifierContains(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdentifierStartsWith(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdentifierEndsWith(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdentifierNot(value) => {
          (
            "identifier".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenEquals(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenInVec(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TokenNotInVec(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TokenLt(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenLte(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenGt(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenGte(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TokenContains(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenStartsWith(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenEndsWith(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TokenNot(value) => {
          (
            "token".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ExpiresEquals(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::ExpiresInVec(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::ExpiresNotInVec(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::ExpiresLt(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::ExpiresLte(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::ExpiresGt(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::ExpiresGte(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::ExpiresNot(value) => {
          (
            "expires".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    TokenEquals(String),
    IdentifierTokenEquals(String, String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::TokenEquals(value) => Self::TokenEquals(value),
        UniqueWhereParam::IdentifierTokenEquals(identifier, token) => {
          Self::IdentifierTokenEquals(identifier, token)
        }
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      identifier: identifier::Set,
      token: token::Set,
      expires: expires::Set,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(identifier.into());
      _params.push(token.into());
      _params.push(expires.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("VerificationToken", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("VerificationToken", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("VerificationToken", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("VerificationToken", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (identifier::Set, token::Set, expires::Set, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (identifier, token, expires, mut _params) = _create;
      _params.push(identifier.into());
      _params.push(token.into());
      _params.push(expires.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("VerificationToken", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod user_wallet {
  use super::{_prisma::*, *};
  pub mod public_key {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::PublicKeyEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::PublicKey(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::PublicKey(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PublicKeyInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::PublicKeyNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::PublicKeyLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::PublicKeyLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::PublicKeyGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::PublicKeyGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::PublicKeyContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::PublicKeyStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::PublicKeyEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::PublicKeyNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPublicKey(value.0)
      }
    }
  }
  pub mod user_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::UserIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UserId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UserIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UserIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UserIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UserIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UserIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UserIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UserIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UserIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUserId(value.0)
      }
    }
  }
  pub mod created_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
  }
  pub mod user {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIs(value)
    }
    pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIsNot(value)
    }
    pub struct Fetch {
      args: user::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::User(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: user::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkUser
    }
    pub struct Link(user::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkUser(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    ["publicKey", "userId", "createdAt"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "publicKey")]
    pub public_key: String,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "user")]
    pub user: Option<Box<super::user::Data>>,
  }
  impl Data {
    pub fn user(&self) -> Result<&super::user::Data, &'static str> {
      self
        .user
        .as_ref()
        .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
  }
  pub enum WithParam {
    User(super::user::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::User(args) => {
          let mut selections = super::user::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("user");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetPublicKey(String),
    SetUserId(String),
    SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
    LinkUser(super::user::UniqueWhereParam),
    UnlinkUser,
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetPublicKey(value) => ("publicKey".to_string(), PrismaValue::String(value)),
        SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
        SetParam::SetCreatedAt(value) => ("createdAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::LinkUser(where_param) => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::UnlinkUser => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
          )
        }
      }
    }
  }
  pub enum OrderByParam {
    PublicKey(Direction),
    UserId(Direction),
    CreatedAt(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::PublicKey(direction) => {
          (
            "publicKey".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UserId(direction) => {
          (
            "userId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::CreatedAt(direction) => {
          (
            "createdAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    PublicKey(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::PublicKey(cursor) => ("publicKey".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    PublicKeyEquals(String),
    PublicKeyInVec(Vec<String>),
    PublicKeyNotInVec(Vec<String>),
    PublicKeyLt(String),
    PublicKeyLte(String),
    PublicKeyGt(String),
    PublicKeyGte(String),
    PublicKeyContains(String),
    PublicKeyStartsWith(String),
    PublicKeyEndsWith(String),
    PublicKeyNot(String),
    UserIdEquals(String),
    UserIdInVec(Vec<String>),
    UserIdNotInVec(Vec<String>),
    UserIdLt(String),
    UserIdLte(String),
    UserIdGt(String),
    UserIdGte(String),
    UserIdContains(String),
    UserIdStartsWith(String),
    UserIdEndsWith(String),
    UserIdNot(String),
    CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UserIs(Vec<super::user::WhereParam>),
    UserIsNot(Vec<super::user::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::PublicKeyEquals(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PublicKeyInVec(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::PublicKeyNotInVec(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::PublicKeyLt(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PublicKeyLte(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PublicKeyGt(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PublicKeyGte(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::PublicKeyContains(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PublicKeyStartsWith(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PublicKeyEndsWith(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::PublicKeyNot(value) => {
          (
            "publicKey".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdEquals(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdNotInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdLt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdLte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdContains(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdStartsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdEndsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdNot(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::CreatedAtEquals(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::CreatedAtInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtNotInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtLt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtLte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtNot(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UserIs(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIsNot(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    PublicKeyEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::PublicKeyEquals(value) => Self::PublicKeyEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      public_key: public_key::Set,
      user: user::Link,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(public_key.into());
      _params.push(user.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("UserWallet", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("UserWallet", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("UserWallet", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("UserWallet", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (public_key::Set, user::Link, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (public_key, user, mut _params) = _create;
      _params.push(public_key.into());
      _params.push(user.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("UserWallet", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod password {
  use super::{_prisma::*, *};
  pub mod hash {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::HashEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Hash(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::HashInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::HashNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::HashLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::HashLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::HashGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::HashGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::HashContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::HashStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::HashEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::HashNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetHash(value.0)
      }
    }
  }
  pub mod user {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIs(value)
    }
    pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIsNot(value)
    }
    pub struct Fetch {
      args: user::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::User(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: user::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkUser
    }
    pub struct Link(user::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkUser(value.0)
      }
    }
  }
  pub mod user_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::UserIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UserId(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::UserId(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UserIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UserIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UserIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UserIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UserIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UserIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UserIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UserIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUserId(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    ["hash", "userId"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "hash")]
    pub hash: String,
    #[serde(rename = "user")]
    pub user: Option<Box<super::user::Data>>,
    #[serde(rename = "userId")]
    pub user_id: String,
  }
  impl Data {
    pub fn user(&self) -> Result<&super::user::Data, &'static str> {
      self
        .user
        .as_ref()
        .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }
  }
  pub enum WithParam {
    User(super::user::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::User(args) => {
          let mut selections = super::user::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("user");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetHash(String),
    LinkUser(super::user::UniqueWhereParam),
    UnlinkUser,
    SetUserId(String),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetHash(value) => ("hash".to_string(), PrismaValue::String(value)),
        SetParam::LinkUser(where_param) => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::UnlinkUser => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
          )
        }
        SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
      }
    }
  }
  pub enum OrderByParam {
    Hash(Direction),
    UserId(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Hash(direction) => {
          (
            "hash".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UserId(direction) => {
          (
            "userId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    UserId(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::UserId(cursor) => ("userId".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    HashEquals(String),
    HashInVec(Vec<String>),
    HashNotInVec(Vec<String>),
    HashLt(String),
    HashLte(String),
    HashGt(String),
    HashGte(String),
    HashContains(String),
    HashStartsWith(String),
    HashEndsWith(String),
    HashNot(String),
    UserIs(Vec<super::user::WhereParam>),
    UserIsNot(Vec<super::user::WhereParam>),
    UserIdEquals(String),
    UserIdInVec(Vec<String>),
    UserIdNotInVec(Vec<String>),
    UserIdLt(String),
    UserIdLte(String),
    UserIdGt(String),
    UserIdGte(String),
    UserIdContains(String),
    UserIdStartsWith(String),
    UserIdEndsWith(String),
    UserIdNot(String),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::HashEquals(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::HashInVec(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::HashNotInVec(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::HashLt(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::HashLte(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::HashGt(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::HashGte(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::HashContains(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::HashStartsWith(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::HashEndsWith(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::HashNot(value) => {
          (
            "hash".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIs(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIsNot(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIdEquals(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdNotInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdLt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdLte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdContains(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdStartsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdEndsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdNot(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    UserIdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(&self, hash: hash::Set, user: user::Link, mut _params: Vec<SetParam>) -> Create {
      _params.push(hash.into());
      _params.push(user.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Password", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Password", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Password", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Password", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (hash::Set, user::Link, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (hash, user, mut _params) = _create;
      _params.push(hash.into());
      _params.push(user.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Password", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod project {
  use super::{_prisma::*, *};
  pub mod id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod title {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::TitleEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Title(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TitleInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TitleNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::TitleLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::TitleLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::TitleGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::TitleGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::TitleContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::TitleStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::TitleEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::TitleNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetTitle(value.0)
      }
    }
  }
  pub mod description {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::DescriptionEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Description(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DescriptionNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DescriptionLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DescriptionLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DescriptionGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DescriptionGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DescriptionContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DescriptionStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DescriptionEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::DescriptionNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDescription(value.0)
      }
    }
  }
  pub mod created_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::CreatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::CreatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
  }
  pub mod updated_at {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
      Set(value).into()
    }
    pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UpdatedAt(direction)
    }
    pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtInVec(value)
    }
    pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
      WhereParam::UpdatedAtNotInVec(value)
    }
    pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLt(value)
    }
    pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtLte(value)
    }
    pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGt(value)
    }
    pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtGte(value)
    }
    pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
      WhereParam::UpdatedAtNot(value)
    }
    pub struct Set(chrono::DateTime<chrono::FixedOffset>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUpdatedAt(value.0)
      }
    }
  }
  pub mod user {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIs(value)
    }
    pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
      WhereParam::UserIsNot(value)
    }
    pub struct Fetch {
      args: user::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::User(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: user::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub fn unlink() -> SetParam {
      SetParam::UnlinkUser
    }
    pub struct Link(user::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkUser(value.0)
      }
    }
  }
  pub mod user_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::UserIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::UserId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::UserIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::UserIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::UserIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::UserIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::UserIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::UserIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::UserIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::UserIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::UserIdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUserId(value.0)
      }
    }
  }
  pub mod github_repos {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn some(value: Vec<git_hub_repo::WhereParam>) -> WhereParam {
      WhereParam::GithubReposSome(value)
    }
    pub fn every(value: Vec<git_hub_repo::WhereParam>) -> WhereParam {
      WhereParam::GithubReposEvery(value)
    }
    pub fn none(value: Vec<git_hub_repo::WhereParam>) -> WhereParam {
      WhereParam::GithubReposNone(value)
    }
    pub struct Fetch {
      args: git_hub_repo::ManyArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<git_hub_repo::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }

      pub fn order_by(mut self, param: git_hub_repo::OrderByParam) -> Self {
        self.args = self.args.order_by(param);
        self
      }

      pub fn skip(mut self, value: i64) -> Self {
        self.args = self.args.skip(value);
        self
      }

      pub fn take(mut self, value: i64) -> Self {
        self.args = self.args.take(value);
        self
      }

      pub fn cursor(mut self, value: impl Into<git_hub_repo::Cursor>) -> Self {
        self.args = self.args.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::GithubRepos(fetch.args)
      }
    }
    pub fn fetch(params: Vec<git_hub_repo::WhereParam>) -> Fetch {
      Fetch {
        args: git_hub_repo::ManyArgs::new(params),
      }
    }
    pub fn link<T: From<Link>>(params: Vec<git_hub_repo::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<git_hub_repo::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkGithubRepos(params)
    }
    pub struct Link(Vec<git_hub_repo::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkGithubRepos(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Selection> {
    [
      "id",
      "title",
      "description",
      "createdAt",
      "updatedAt",
      "userId",
    ]
    .into_iter()
    .map(|o| {
      let builder = Selection::builder(o);
      builder.build()
    })
    .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "title")]
    pub title: String,
    #[serde(rename = "description")]
    pub description: String,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime<chrono::FixedOffset>,
    #[serde(rename = "user")]
    pub user: Option<Box<super::user::Data>>,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "githubRepos")]
    pub github_repos: Option<Vec<super::git_hub_repo::Data>>,
  }
  impl Data {
    pub fn user(&self) -> Result<&super::user::Data, &'static str> {
      self
        .user
        .as_ref()
        .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref())
    }

    pub fn github_repos(&self) -> Result<&Vec<super::git_hub_repo::Data>, &'static str> {
      self
        .github_repos
        .as_ref()
        .ok_or("Attempted to access 'github_repos' but did not fetch it using the .with() syntax")
    }
  }
  pub enum WithParam {
    User(super::user::UniqueArgs),
    GithubRepos(super::git_hub_repo::ManyArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::User(args) => {
          let mut selections = super::user::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("user");
          builder.nested_selections(selections);
          builder.build()
        }
        Self::GithubRepos(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections.extend(super::git_hub_repo::_outputs());
          let mut builder = Selection::builder("githubRepos");
          builder
            .nested_selections(nested_selections)
            .set_arguments(arguments);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetId(String),
    SetTitle(String),
    SetDescription(String),
    SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
    SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
    LinkUser(super::user::UniqueWhereParam),
    UnlinkUser,
    SetUserId(String),
    LinkGithubRepos(Vec<super::git_hub_repo::UniqueWhereParam>),
    UnlinkGithubRepos(Vec<super::git_hub_repo::UniqueWhereParam>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
        SetParam::SetTitle(value) => ("title".to_string(), PrismaValue::String(value)),
        SetParam::SetDescription(value) => ("description".to_string(), PrismaValue::String(value)),
        SetParam::SetCreatedAt(value) => ("createdAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::SetUpdatedAt(value) => ("updatedAt".to_string(), PrismaValue::DateTime(value)),
        SetParam::LinkUser(where_param) => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::UnlinkUser => {
          (
            "user".to_string(),
            PrismaValue::Object(vec![("disconnect".to_string(), PrismaValue::Boolean(true))]),
          )
        }
        SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
        SetParam::LinkGithubRepos(where_params) => {
          (
            "githubRepos".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                where_params
                  .into_iter()
                  .map(Into::<super::git_hub_repo::WhereParam>::into),
              )),
            )]),
          )
        }
        SetParam::UnlinkGithubRepos(where_params) => {
          (
            "githubRepos".to_string(),
            PrismaValue::Object(vec![(
              "disconnect".to_string(),
              PrismaValue::Object(
                transform_equals(
                  where_params
                    .into_iter()
                    .map(Into::<super::git_hub_repo::WhereParam>::into),
                )
                .into_iter()
                .collect(),
              ),
            )]),
          )
        }
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    Title(Direction),
    Description(Direction),
    CreatedAt(Direction),
    UpdatedAt(Direction),
    UserId(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(direction) => ("id".to_string(), PrismaValue::String(direction.to_string())),
        Self::Title(direction) => {
          (
            "title".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Description(direction) => {
          (
            "description".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::CreatedAt(direction) => {
          (
            "createdAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UpdatedAt(direction) => {
          (
            "updatedAt".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::UserId(direction) => {
          (
            "userId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Id(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(String),
    IdInVec(Vec<String>),
    IdNotInVec(Vec<String>),
    IdLt(String),
    IdLte(String),
    IdGt(String),
    IdGte(String),
    IdContains(String),
    IdStartsWith(String),
    IdEndsWith(String),
    IdNot(String),
    TitleEquals(String),
    TitleInVec(Vec<String>),
    TitleNotInVec(Vec<String>),
    TitleLt(String),
    TitleLte(String),
    TitleGt(String),
    TitleGte(String),
    TitleContains(String),
    TitleStartsWith(String),
    TitleEndsWith(String),
    TitleNot(String),
    DescriptionEquals(String),
    DescriptionInVec(Vec<String>),
    DescriptionNotInVec(Vec<String>),
    DescriptionLt(String),
    DescriptionLte(String),
    DescriptionGt(String),
    DescriptionGte(String),
    DescriptionContains(String),
    DescriptionStartsWith(String),
    DescriptionEndsWith(String),
    DescriptionNot(String),
    CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
    UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
    UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    UserIs(Vec<super::user::WhereParam>),
    UserIsNot(Vec<super::user::WhereParam>),
    UserIdEquals(String),
    UserIdInVec(Vec<String>),
    UserIdNotInVec(Vec<String>),
    UserIdLt(String),
    UserIdLte(String),
    UserIdGt(String),
    UserIdGte(String),
    UserIdContains(String),
    UserIdStartsWith(String),
    UserIdEndsWith(String),
    UserIdNot(String),
    GithubReposSome(Vec<super::git_hub_repo::WhereParam>),
    GithubReposEvery(Vec<super::git_hub_repo::WhereParam>),
    GithubReposNone(Vec<super::git_hub_repo::WhereParam>),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::IdEquals(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdNotInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdLt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdLte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdContains(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdStartsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdEndsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdNot(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleEquals(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleInVec(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TitleNotInVec(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::TitleLt(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleLte(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleGt(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleGte(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::TitleContains(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TitleStartsWith(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TitleEndsWith(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::TitleNot(value) => {
          (
            "title".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionEquals(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionInVec(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::DescriptionNotInVec(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::DescriptionLt(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionLte(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionGt(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionGte(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::DescriptionContains(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::DescriptionStartsWith(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::DescriptionEndsWith(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::DescriptionNot(value) => {
          (
            "description".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::CreatedAtEquals(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::CreatedAtInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtNotInVec(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::CreatedAtLt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtLte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGt(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtGte(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::CreatedAtNot(value) => {
          (
            "createdAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtEquals(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              PrismaValue::DateTime(value),
            )]),
          )
        }
        Self::UpdatedAtInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtNotInVec(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(
                value
                  .into_iter()
                  .map(|v| PrismaValue::DateTime(v))
                  .collect(),
              ),
            )]),
          )
        }
        Self::UpdatedAtLt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtLte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGt(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtGte(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UpdatedAtNot(value) => {
          (
            "updatedAt".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::DateTime(value))]),
          )
        }
        Self::UserIs(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIsNot(value) => {
          (
            "user".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::UserIdEquals(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdNotInVec(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::UserIdLt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdLte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGt(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdGte(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::UserIdContains(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdStartsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdEndsWith(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::UserIdNot(value) => {
          (
            "userId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::GithubReposSome(value) => {
          (
            "githubRepos".to_string(),
            SerializedWhereValue::Object(vec![(
              "some".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::GithubReposEvery(value) => {
          (
            "githubRepos".to_string(),
            SerializedWhereValue::Object(vec![(
              "every".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::GithubReposNone(value) => {
          (
            "githubRepos".to_string(),
            SerializedWhereValue::Object(vec![(
              "none".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    IdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      title: title::Set,
      description: description::Set,
      user: user::Link,
      mut _params: Vec<SetParam>,
    ) -> Create {
      _params.push(title.into());
      _params.push(description.into());
      _params.push(user.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("Project", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("Project", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("Project", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("Project", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (title::Set, description::Set, user::Link, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (title, description, user, mut _params) = _create;
      _params.push(title.into());
      _params.push(description.into());
      _params.push(user.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("Project", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod git_hub_repo {
  use super::{_prisma::*, *};
  pub mod id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: String) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::IdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::IdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::IdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod owner {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::OwnerEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Owner(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OwnerInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::OwnerNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::OwnerLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::OwnerLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::OwnerGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::OwnerGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::OwnerContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::OwnerStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::OwnerEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::OwnerNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetOwner(value.0)
      }
    }
  }
  pub mod name {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
  }
  pub mod project {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn is(value: Vec<project::WhereParam>) -> WhereParam {
      WhereParam::ProjectIs(value)
    }
    pub fn is_not(value: Vec<project::WhereParam>) -> WhereParam {
      WhereParam::ProjectIsNot(value)
    }
    pub struct Fetch {
      args: project::UniqueArgs,
    }
    impl Fetch {
      pub fn with(mut self, params: impl Into<project::WithParam>) -> Self {
        self.args = self.args.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Project(fetch.args)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch {
        args: project::UniqueArgs::new(),
      }
    }
    pub fn link<T: From<Link>>(value: project::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub struct Link(project::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkProject(value.0)
      }
    }
  }
  pub mod project_id {
    use super::{
      super::*,
      Cursor,
      OrderByParam,
      SetParam,
      UniqueWhereParam,
      WhereParam,
      WithParam,
      _prisma::*,
    };
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::ProjectIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::ProjectId(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProjectIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::ProjectIdNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::ProjectIdLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::ProjectIdLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::ProjectIdGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::ProjectIdGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::ProjectIdContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::ProjectIdStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::ProjectIdEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::ProjectIdNot(value)
    }
    pub struct Set(Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetProjectId(value.0)
      }
    }
  }
  pub fn owner_name<T: From<UniqueWhereParam>>(owner: String, name: String) -> T {
    UniqueWhereParam::OwnerNameEquals(owner, name).into()
  }
  pub fn _outputs() -> Vec<Selection> {
    ["id", "owner", "name", "projectId"]
      .into_iter()
      .map(|o| {
        let builder = Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "owner")]
    pub owner: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(
      rename = "project",
      default,
      skip_serializing_if = "Option::is_none",
      with = "prisma_client_rust::serde::double_option"
    )]
    pub project: Option<Option<Box<super::project::Data>>>,
    #[serde(rename = "projectId")]
    pub project_id: Option<String>,
  }
  impl Data {
    pub fn project(&self) -> Result<Option<&super::project::Data>, &'static str> {
      self
        .project
        .as_ref()
        .ok_or("Attempted to access 'project' but did not fetch it using the .with() syntax")
        .map(|v| v.as_ref().map(|v| v.as_ref()))
    }
  }
  pub enum WithParam {
    Project(super::project::UniqueArgs),
  }
  impl Into<Selection> for WithParam {
    fn into(self) -> Selection {
      match self {
        Self::Project(args) => {
          let mut selections = super::project::_outputs();
          selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
          let mut builder = Selection::builder("project");
          builder.nested_selections(selections);
          builder.build()
        }
      }
    }
  }
  pub enum SetParam {
    SetId(String),
    SetOwner(String),
    SetName(String),
    LinkProject(super::project::UniqueWhereParam),
    SetProjectId(Option<String>),
  }
  impl Into<(String, PrismaValue)> for SetParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
        SetParam::SetOwner(value) => ("owner".to_string(), PrismaValue::String(value)),
        SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
        SetParam::LinkProject(where_param) => {
          (
            "project".to_string(),
            PrismaValue::Object(vec![(
              "connect".to_string(),
              PrismaValue::Object(transform_equals(
                vec![Into::<super::project::WhereParam>::into(where_param)].into_iter(),
              )),
            )]),
          )
        }
        SetParam::SetProjectId(value) => {
          (
            "projectId".to_string(),
            value
              .map(|value| PrismaValue::String(value))
              .unwrap_or(PrismaValue::Null),
          )
        }
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    Owner(Direction),
    Name(Direction),
    ProjectId(Direction),
  }
  impl Into<(String, PrismaValue)> for OrderByParam {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(direction) => ("id".to_string(), PrismaValue::String(direction.to_string())),
        Self::Owner(direction) => {
          (
            "owner".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::Name(direction) => {
          (
            "name".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
        Self::ProjectId(direction) => {
          (
            "projectId".to_string(),
            PrismaValue::String(direction.to_string()),
          )
        }
      }
    }
  }
  pub enum Cursor {
    Id(String),
  }
  impl Into<(String, PrismaValue)> for Cursor {
    fn into(self) -> (String, PrismaValue) {
      match self {
        Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    OwnerNameEquals(String, String),
    IdEquals(String),
    IdInVec(Vec<String>),
    IdNotInVec(Vec<String>),
    IdLt(String),
    IdLte(String),
    IdGt(String),
    IdGte(String),
    IdContains(String),
    IdStartsWith(String),
    IdEndsWith(String),
    IdNot(String),
    OwnerEquals(String),
    OwnerInVec(Vec<String>),
    OwnerNotInVec(Vec<String>),
    OwnerLt(String),
    OwnerLte(String),
    OwnerGt(String),
    OwnerGte(String),
    OwnerContains(String),
    OwnerStartsWith(String),
    OwnerEndsWith(String),
    OwnerNot(String),
    NameEquals(String),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameNot(String),
    ProjectIs(Vec<super::project::WhereParam>),
    ProjectIsNot(Vec<super::project::WhereParam>),
    ProjectIdEquals(Option<String>),
    ProjectIdInVec(Vec<String>),
    ProjectIdNotInVec(Vec<String>),
    ProjectIdLt(String),
    ProjectIdLte(String),
    ProjectIdGt(String),
    ProjectIdGte(String),
    ProjectIdContains(String),
    ProjectIdStartsWith(String),
    ProjectIdEndsWith(String),
    ProjectIdNot(String),
  }
  impl Into<SerializedWhere> for WhereParam {
    fn into(self) -> SerializedWhere {
      match self {
        Self::Not(value) => {
          (
            "NOT".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::Or(value) => {
          (
            "OR".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::And(value) => {
          (
            "AND".to_string(),
            SerializedWhereValue::List(
              value
                .into_iter()
                .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                .collect(),
            ),
          )
        }
        Self::OwnerNameEquals(owner, name) => {
          (
            "owner_name".to_string(),
            SerializedWhereValue::Object(vec![
              ("owner".to_string(), PrismaValue::String(owner)),
              ("name".to_string(), PrismaValue::String(name)),
            ]),
          )
        }
        Self::IdEquals(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdNotInVec(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::IdLt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdLte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGt(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdGte(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::IdContains(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdStartsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdEndsWith(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::IdNot(value) => {
          (
            "id".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerEquals(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerInVec(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OwnerNotInVec(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::OwnerLt(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerLte(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerGt(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerGte(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::OwnerContains(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OwnerStartsWith(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OwnerEndsWith(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::OwnerNot(value) => {
          (
            "owner".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameEquals(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("equals".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameInVec(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::NameNotInVec(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::NameLt(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameLte(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameGt(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameGte(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::NameContains(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameStartsWith(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameEndsWith(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::NameNot(value) => {
          (
            "name".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProjectIs(value) => {
          (
            "project".to_string(),
            SerializedWhereValue::Object(vec![(
              "is".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ProjectIsNot(value) => {
          (
            "project".to_string(),
            SerializedWhereValue::Object(vec![(
              "isNot".to_string(),
              PrismaValue::Object(transform_equals(
                value.into_iter().map(Into::<SerializedWhere>::into),
              )),
            )]),
          )
        }
        Self::ProjectIdEquals(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| PrismaValue::String(value))
                .unwrap_or(PrismaValue::Null),
            )]),
          )
        }
        Self::ProjectIdInVec(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "in".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProjectIdNotInVec(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
            )]),
          )
        }
        Self::ProjectIdLt(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![("lt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProjectIdLte(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![("lte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProjectIdGt(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![("gt".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProjectIdGte(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![("gte".to_string(), PrismaValue::String(value))]),
          )
        }
        Self::ProjectIdContains(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProjectIdStartsWith(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProjectIdEndsWith(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              PrismaValue::String(value),
            )]),
          )
        }
        Self::ProjectIdNot(value) => {
          (
            "projectId".to_string(),
            SerializedWhereValue::Object(vec![("not".to_string(), PrismaValue::String(value))]),
          )
        }
      }
    }
  }
  pub enum UniqueWhereParam {
    OwnerNameEquals(String, String),
    IdEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::OwnerNameEquals(owner, name) => Self::OwnerNameEquals(owner, name),
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
  pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type FindUnique<'a> =
    prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> =
    prisma_client_rust::FindMany<'a, WhereParam, WithParam, OrderByParam, Cursor, SetParam, Data>;
  pub type FindFirst<'a> =
    prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
  pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
  pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(&self, owner: owner::Set, name: name::Set, mut _params: Vec<SetParam>) -> Create {
      _params.push(owner.into());
      _params.push(name.into());
      Create::new(
        self.client._new_query_context(),
        QueryInfo::new("GitHubRepo", _outputs()),
        _params,
      )
    }

    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      FindUnique::new(
        self.client._new_query_context(),
        QueryInfo::new("GitHubRepo", _outputs()),
        param.into(),
      )
    }

    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      FindFirst::new(
        self.client._new_query_context(),
        QueryInfo::new("GitHubRepo", _outputs()),
        params,
      )
    }

    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      FindMany::new(
        self.client._new_query_context(),
        QueryInfo::new("GitHubRepo", _outputs()),
        params,
      )
    }

    pub fn upsert(
      &self,
      _where: UniqueWhereParam,
      _create: (owner::Set, name::Set, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert {
      let (owner, name, mut _params) = _create;
      _params.push(owner.into());
      _params.push(name.into());
      Upsert::new(
        self.client._new_query_context(),
        QueryInfo::new("GitHubRepo", _outputs()),
        _where.into(),
        _params,
        _update,
      )
    }
  }
}
pub mod _prisma {
  use std::{fmt, sync::Arc};

  use prisma_client_rust::{
    queries::QueryContext,
    query_core::{QueryExecutor, QuerySchema},
    raw,
    ExecuteRaw,
    QueryRaw,
  };
  use serde::{Deserialize, Serialize};

  use super::*;
  pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
  }
  impl fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("PrismaClient").finish()
    }
  }
  impl PrismaClient {
    pub(super) fn _new_query_context(&self) -> QueryContext {
      QueryContext::new(&self.executor, self.query_schema.clone())
    }

    pub(super) fn _new(
      executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
      query_schema: Arc<QuerySchema>,
    ) -> Self {
      Self {
        executor,
        query_schema,
      }
    }

    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
      &self,
      query: raw::Raw,
    ) -> QueryResult<Vec<T>> {
      QueryRaw::new(
        QueryContext::new(&self.executor, self.query_schema.clone()),
        query,
        DATABASE_STR,
      )
      .exec()
      .await
    }

    pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
      ExecuteRaw::new(
        QueryContext::new(&self.executor, self.query_schema.clone()),
        query,
        DATABASE_STR,
      )
      .exec()
      .await
    }

    pub fn account(&self) -> account::Actions {
      account::Actions { client: &self }
    }

    pub fn user(&self) -> user::Actions {
      user::Actions { client: &self }
    }

    pub fn email(&self) -> email::Actions {
      email::Actions { client: &self }
    }

    pub fn verification_token(&self) -> verification_token::Actions {
      verification_token::Actions { client: &self }
    }

    pub fn user_wallet(&self) -> user_wallet::Actions {
      user_wallet::Actions { client: &self }
    }

    pub fn password(&self) -> password::Actions {
      password::Actions { client: &self }
    }

    pub fn project(&self) -> project::Actions {
      project::Actions { client: &self }
    }

    pub fn git_hub_repo(&self) -> git_hub_repo::Actions {
      git_hub_repo::Actions { client: &self }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum AccountScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "accountType")]
    AccountType,
    #[serde(rename = "provider")]
    Provider,
    #[serde(rename = "providerAccountId")]
    ProviderAccountId,
    #[serde(rename = "refreshToken")]
    RefreshToken,
    #[serde(rename = "refreshTokenExpiresIn")]
    RefreshTokenExpiresIn,
    #[serde(rename = "accessToken")]
    AccessToken,
    #[serde(rename = "expiresAt")]
    ExpiresAt,
    #[serde(rename = "tokenType")]
    TokenType,
    #[serde(rename = "scope")]
    Scope,
    #[serde(rename = "idToken")]
    IdToken,
    #[serde(rename = "sessionState")]
    SessionState,
    #[serde(rename = "oauthTokenSecret")]
    OauthTokenSecret,
    #[serde(rename = "oauthToken")]
    OauthToken,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
  }
  impl ToString for AccountScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::UserId => "userId".to_string(),
        Self::AccountType => "accountType".to_string(),
        Self::Provider => "provider".to_string(),
        Self::ProviderAccountId => "providerAccountId".to_string(),
        Self::RefreshToken => "refreshToken".to_string(),
        Self::RefreshTokenExpiresIn => "refreshTokenExpiresIn".to_string(),
        Self::AccessToken => "accessToken".to_string(),
        Self::ExpiresAt => "expiresAt".to_string(),
        Self::TokenType => "tokenType".to_string(),
        Self::Scope => "scope".to_string(),
        Self::IdToken => "idToken".to_string(),
        Self::SessionState => "sessionState".to_string(),
        Self::OauthTokenSecret => "oauthTokenSecret".to_string(),
        Self::OauthToken => "oauthToken".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
        Self::UpdatedAt => "updatedAt".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum UserScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "primaryEmail")]
    PrimaryEmail,
    #[serde(rename = "image")]
    Image,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
  }
  impl ToString for UserScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Name => "name".to_string(),
        Self::PrimaryEmail => "primaryEmail".to_string(),
        Self::Image => "image".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
        Self::UpdatedAt => "updatedAt".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum EmailScalarFieldEnum {
    #[serde(rename = "email")]
    Email,
    #[serde(rename = "emailVerified")]
    EmailVerified,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "createdAt")]
    CreatedAt,
  }
  impl ToString for EmailScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Email => "email".to_string(),
        Self::EmailVerified => "emailVerified".to_string(),
        Self::UserId => "userId".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum VerificationTokenScalarFieldEnum {
    #[serde(rename = "identifier")]
    Identifier,
    #[serde(rename = "token")]
    Token,
    #[serde(rename = "expires")]
    Expires,
  }
  impl ToString for VerificationTokenScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Identifier => "identifier".to_string(),
        Self::Token => "token".to_string(),
        Self::Expires => "expires".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum UserWalletScalarFieldEnum {
    #[serde(rename = "publicKey")]
    PublicKey,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "createdAt")]
    CreatedAt,
  }
  impl ToString for UserWalletScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::PublicKey => "publicKey".to_string(),
        Self::UserId => "userId".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum PasswordScalarFieldEnum {
    #[serde(rename = "hash")]
    Hash,
    #[serde(rename = "userId")]
    UserId,
  }
  impl ToString for PasswordScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Hash => "hash".to_string(),
        Self::UserId => "userId".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum ProjectScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "title")]
    Title,
    #[serde(rename = "description")]
    Description,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
    #[serde(rename = "userId")]
    UserId,
  }
  impl ToString for ProjectScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Title => "title".to_string(),
        Self::Description => "description".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
        Self::UpdatedAt => "updatedAt".to_string(),
        Self::UserId => "userId".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum GitHubRepoScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "owner")]
    Owner,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "projectId")]
    ProjectId,
  }
  impl ToString for GitHubRepoScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Owner => "owner".to_string(),
        Self::Name => "name".to_string(),
        Self::ProjectId => "projectId".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
  pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
  }
  impl ToString for SortOrder {
    fn to_string(&self) -> String {
      match self {
        Self::Asc => "asc".to_string(),
        Self::Desc => "desc".to_string(),
      }
    }
  }
}
pub use _prisma::PrismaClient;
