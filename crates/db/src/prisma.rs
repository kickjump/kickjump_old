// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
    transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
    QueryGraphBuilderError, QuerySchema,
};
use prisma_client_rust::{chrono, operator::Operator, serde_json, CountResult, Direction};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "// => CLIENT START\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n  referentialIntegrity = \"prisma\"\n}\n\ngenerator client {\n  provider      = \"cargo prisma\"\n  output        = \"../../crates/prisma/src/prisma.rs\"\n  binaryTargets = [\"native\"]\n  previewFeatures = [\"referentialIntegrity\"]\n}\n\n// => CLIENT END\n\n/// Users can have multiple ID's\nmodel Account {\n  /// The account id.\n  id                    String   @id @default(cuid())\n  /// The userId on the authentication service.\n  userId                String   @map(\"user_id\")\n  /// The type of account.\n  accountType           String   @map(\"account_type\")\n  /// The name of the provider for this account. In this case GitHub is the only\n  /// option.\n  provider              String\n  providerAccountId     String   @map(\"provider_account_id\")\n  refreshToken          String?  @map(\"refresh_token\") @db.Text\n  /// This is a GitHub login specific field which allows for next-auth to\n  //automatically refresh the token.\n  refreshTokenExpiresIn Int?     @map(\"refresh_token_expires_in\")\n  /// The access token for this account.\n  accessToken           String?  @map(\"access_token\") @db.Text\n  /// The timestamp of when the token expires.\n  expiresAt             Int?     @map(\"expires_at\")\n  tokenType             String?  @map(\"token_type\")\n  scope                 String?\n  idToken               String?  @map(\"id_token\") @db.Text\n  sessionState          String?  @map(\"session_state\")\n  oauthTokenSecret      String?  @map(\"oauth_token_secret\")\n  oauthToken            String?  @map(\"oauth_token\")\n  /// When the database record was first created.\n  createdAt             DateTime @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt             DateTime @updatedAt @map(\"updated_at\")\n  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n  @@map(\"accounts\")\n}\n\n/// A user model. Be careful when populating to avoid sending sensitive data to\n/// the client.\n///\n/// It might be worthwhile splitting up the model for safety in the future.\nmodel User {\n  /// The user id.\n  id           String       @id @default(cuid())\n  /// The name of the user which is retrieved from their GitHub profile when\n  /// signing up.\n  name         String?\n  /// The primary email address for this user. Only verified email address can\n  /// be set as primary.\n  primaryEmail String?      @map(\"primary_email\")\n  /// The emails for this user.\n  emails       Email[]\n  /// A profile image url if one exists.\n  image        String?\n  /// The user password is seperated from the user to prevent unitentionally\n  /// sending it to the client.\n  password     Password?\n  /// Connected authentication accounts for this user.\n  accounts     Account[]\n  /// A user can attach multiple wallets to their profile. Once attached a\n  /// wallet can be used to sign in.\n  wallets      UserWallet[]\n  /// Projects created by this user.\n  projects     Project[]\n  /// When the database record was first created.\n  createdAt    DateTime     @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt    DateTime     @updatedAt @map(\"updated_at\")\n\n  @@map(\"users\")\n}\n\n/// Rather than storing a single email per user, a user may store multiple email\n/// address and set one as their primary.\nmodel Email {\n  /// The primary email address for this user.\n  email         String?   @unique\n  /// The date the email was verified.\n  emailVerified DateTime? @map(\"email_verified\")\n  /// The userId field for the relation.\n  userId        String    @unique @map(\"user_id\")\n  /// When the database record was first created.\n  createdAt     DateTime  @default(now()) @map(\"created_at\")\n  /// The owner of this email address.\n  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n  @@map(\"verificationtokens\")\n}\n\n/// Each wallet can be attached to a maximum of one user.\nmodel UserWallet {\n  /// The wallet public key. If a user wants to transfer the wallet to another\n  /// user they must first delete it from their current user account.\n  publicKey String   @unique @map(\"public_key\")\n  /// The userId field for the relation.\n  userId    String   @map(\"user_id\")\n  /// When the database record was first created.\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  /// The owner of this wallet.\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel Password {\n  /// The hashed password.\n  hash   String\n  /// The user this password is for.\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  /// The user id for the relation.\n  userId String @unique @map(\"user_id\")\n}\n\nmodel Project {\n  /// The project id.\n  id          String   @id @default(cuid())\n  /// The project title.\n  title       String\n  /// The project description as a markdown compatible string.\n  description String\n  /// When the database record was first created.\n  createdAt   DateTime @default(now()) @map(\"created_at\")\n  /// When the database record was last updated.\n  updatedAt   DateTime @updatedAt @map(\"updated_at\")\n  /// The owner of this project.\n  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  /// The id of the user that owns this project.\n  userId      String   @map(\"user_id\")\n}\n" ;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient {
        executor,
        query_schema,
    })
}
impl PrismaClient {
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
        &self,
        query: &str,
    ) -> QueryResult<Vec<T>> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "queryRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await
    }
    pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "executeRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await.map(|result: i64| result)
    }
    pub fn account(&self) -> account::Actions {
        account::Actions { client: &self }
    }
    pub fn user(&self) -> user::Actions {
        user::Actions { client: &self }
    }
    pub fn email(&self) -> email::Actions {
        email::Actions { client: &self }
    }
    pub fn verification_token(&self) -> verification_token::Actions {
        verification_token::Actions { client: &self }
    }
    pub fn user_wallet(&self) -> user_wallet::Actions {
        user_wallet::Actions { client: &self }
    }
    pub fn password(&self) -> password::Actions {
        password::Actions { client: &self }
    }
    pub fn project(&self) -> project::Actions {
        project::Actions { client: &self }
    }
}
pub mod account {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod account_type {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccountTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AccountType(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountTypeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountTypeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccountTypeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccountTypeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccountTypeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccountTypeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccountTypeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccountTypeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccountTypeEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccountTypeNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccountType(value.0)
            }
        }
    }
    pub mod provider {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ProviderEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Provider(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProviderInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProviderNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ProviderLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ProviderLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ProviderGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ProviderGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ProviderContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ProviderStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ProviderEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ProviderNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetProvider(value.0)
            }
        }
    }
    pub mod provider_account_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ProviderAccountId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProviderAccountIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ProviderAccountIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ProviderAccountIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetProviderAccountId(value.0)
            }
        }
    }
    pub mod refresh_token {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RefreshTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::RefreshToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RefreshTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RefreshTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::RefreshTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::RefreshTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::RefreshTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::RefreshTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::RefreshTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::RefreshTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::RefreshTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::RefreshTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRefreshToken(value.0)
            }
        }
    }
    pub mod refresh_token_expires_in {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::RefreshTokenExpiresInEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::RefreshTokenExpiresIn(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRefreshTokenExpiresIn(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRefreshTokenExpiresIn(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRefreshTokenExpiresIn(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRefreshTokenExpiresIn(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RefreshTokenExpiresInInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RefreshTokenExpiresInNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::RefreshTokenExpiresInLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::RefreshTokenExpiresInLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::RefreshTokenExpiresInGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::RefreshTokenExpiresInGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::RefreshTokenExpiresInNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRefreshTokenExpiresIn(value.0)
            }
        }
    }
    pub mod access_token {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AccessTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AccessToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccessTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccessTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccessTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccessTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccessTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccessTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccessTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccessTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccessTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccessTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccessToken(value.0)
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementExpiresAt(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementExpiresAt(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyExpiresAt(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideExpiresAt(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::ExpiresAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::ExpiresAtNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::ExpiresAtLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::ExpiresAtLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::ExpiresAtGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::ExpiresAtGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::ExpiresAtNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
    }
    pub mod token_type {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TokenTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TokenType(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokenTypeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokenTypeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TokenTypeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TokenTypeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TokenTypeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TokenTypeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TokenTypeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TokenTypeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TokenTypeEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TokenTypeNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTokenType(value.0)
            }
        }
    }
    pub mod scope {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ScopeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Scope(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ScopeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ScopeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ScopeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ScopeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ScopeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ScopeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ScopeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ScopeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ScopeEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ScopeNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetScope(value.0)
            }
        }
    }
    pub mod id_token {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::IdTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::IdToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIdToken(value.0)
            }
        }
    }
    pub mod session_state {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::SessionStateEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::SessionState(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionStateInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionStateNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SessionStateLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SessionStateLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SessionStateGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SessionStateGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SessionStateContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SessionStateStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SessionStateEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SessionStateNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSessionState(value.0)
            }
        }
    }
    pub mod oauth_token_secret {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::OauthTokenSecretEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::OauthTokenSecret(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OauthTokenSecretInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OauthTokenSecretNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::OauthTokenSecretNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetOauthTokenSecret(value.0)
            }
        }
    }
    pub mod oauth_token {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::OauthTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::OauthToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OauthTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OauthTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::OauthTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::OauthTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::OauthTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::OauthTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::OauthTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::OauthTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::OauthTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::OauthTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetOauthToken(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub fn provider_provider_account_id<T: From<UniqueWhereParam>>(
        provider: String,
        provider_account_id: String,
    ) -> T {
        UniqueWhereParam::ProviderProviderAccountIdEquals(provider, provider_account_id).into()
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("id"),
            Output::new("userId"),
            Output::new("accountType"),
            Output::new("provider"),
            Output::new("providerAccountId"),
            Output::new("refreshToken"),
            Output::new("refreshTokenExpiresIn"),
            Output::new("accessToken"),
            Output::new("expiresAt"),
            Output::new("tokenType"),
            Output::new("scope"),
            Output::new("idToken"),
            Output::new("sessionState"),
            Output::new("oauthTokenSecret"),
            Output::new("oauthToken"),
            Output::new("createdAt"),
            Output::new("updatedAt"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "userId")]
        pub user_id: String,
        #[serde(rename = "accountType")]
        pub account_type: String,
        #[serde(rename = "provider")]
        pub provider: String,
        #[serde(rename = "providerAccountId")]
        pub provider_account_id: String,
        #[serde(rename = "refreshToken")]
        pub refresh_token: Option<String>,
        #[serde(rename = "refreshTokenExpiresIn")]
        pub refresh_token_expires_in: Option<i32>,
        #[serde(rename = "accessToken")]
        pub access_token: Option<String>,
        #[serde(rename = "expiresAt")]
        pub expires_at: Option<i32>,
        #[serde(rename = "tokenType")]
        pub token_type: Option<String>,
        #[serde(rename = "scope")]
        pub scope: Option<String>,
        #[serde(rename = "idToken")]
        pub id_token: Option<String>,
        #[serde(rename = "sessionState")]
        pub session_state: Option<String>,
        #[serde(rename = "oauthTokenSecret")]
        pub oauth_token_secret: Option<String>,
        #[serde(rename = "oauthToken")]
        pub oauth_token: Option<String>,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetUserId(String),
        SetAccountType(String),
        SetProvider(String),
        SetProviderAccountId(String),
        SetRefreshToken(Option<String>),
        SetRefreshTokenExpiresIn(Option<i32>),
        IncrementRefreshTokenExpiresIn(i32),
        DecrementRefreshTokenExpiresIn(i32),
        MultiplyRefreshTokenExpiresIn(i32),
        DivideRefreshTokenExpiresIn(i32),
        SetAccessToken(Option<String>),
        SetExpiresAt(Option<i32>),
        IncrementExpiresAt(i32),
        DecrementExpiresAt(i32),
        MultiplyExpiresAt(i32),
        DivideExpiresAt(i32),
        SetTokenType(Option<String>),
        SetScope(Option<String>),
        SetIdToken(Option<String>),
        SetSessionState(Option<String>),
        SetOauthTokenSecret(Option<String>),
        SetOauthToken(Option<String>),
        SetCreatedAt(chrono::DateTime<chrono::Utc>),
        SetUpdatedAt(chrono::DateTime<chrono::Utc>),
        LinkUser(super::user::UniqueWhereParam),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetAccountType(value) => Field {
                    name: "accountType".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetProvider(value) => Field {
                    name: "provider".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetProviderAccountId(value) => Field {
                    name: "providerAccountId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetRefreshToken(value) => Field {
                    name: "refreshToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetRefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::IncrementRefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "increment".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DecrementRefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "decrement".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::MultiplyRefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "multiply".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DivideRefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "divide".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetAccessToken(value) => Field {
                    name: "accessToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::IncrementExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "increment".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DecrementExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "decrement".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::MultiplyExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "multiply".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DivideExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "divide".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetTokenType(value) => Field {
                    name: "tokenType".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetScope(value) => Field {
                    name: "scope".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetIdToken(value) => Field {
                    name: "idToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetSessionState(value) => Field {
                    name: "sessionState".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetOauthTokenSecret(value) => Field {
                    name: "oauthTokenSecret".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetOauthToken(value) => Field {
                    name: "oauthToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetCreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        UserId(Direction),
        AccountType(Direction),
        Provider(Direction),
        ProviderAccountId(Direction),
        RefreshToken(Direction),
        RefreshTokenExpiresIn(Direction),
        AccessToken(Direction),
        ExpiresAt(Direction),
        TokenType(Direction),
        Scope(Direction),
        IdToken(Direction),
        SessionState(Direction),
        OauthTokenSecret(Direction),
        OauthToken(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AccountType(direction) => Field {
                    name: "accountType".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Provider(direction) => Field {
                    name: "provider".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::ProviderAccountId(direction) => Field {
                    name: "providerAccountId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::RefreshToken(direction) => Field {
                    name: "refreshToken".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresIn(direction) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AccessToken(direction) => Field {
                    name: "accessToken".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::ExpiresAt(direction) => Field {
                    name: "expiresAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::TokenType(direction) => Field {
                    name: "tokenType".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Scope(direction) => Field {
                    name: "scope".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::IdToken(direction) => Field {
                    name: "idToken".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::SessionState(direction) => Field {
                    name: "sessionState".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::OauthTokenSecret(direction) => Field {
                    name: "oauthTokenSecret".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::OauthToken(direction) => Field {
                    name: "oauthToken".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(direction) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(direction) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(String),
        UserId(String),
        AccountType(String),
        Provider(String),
        ProviderAccountId(String),
        RefreshToken(String),
        RefreshTokenExpiresIn(i32),
        AccessToken(String),
        ExpiresAt(i32),
        TokenType(String),
        Scope(String),
        IdToken(String),
        SessionState(String),
        OauthTokenSecret(String),
        OauthToken(String),
        CreatedAt(chrono::DateTime<chrono::Utc>),
        UpdatedAt(chrono::DateTime<chrono::Utc>),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AccountType(value) => Field {
                    name: "accountType".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Provider(value) => Field {
                    name: "provider".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::ProviderAccountId(value) => Field {
                    name: "providerAccountId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::RefreshToken(value) => Field {
                    name: "refreshToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresIn(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AccessToken(value) => Field {
                    name: "accessToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::ExpiresAt(value) => Field {
                    name: "expiresAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::TokenType(value) => Field {
                    name: "tokenType".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Scope(value) => Field {
                    name: "scope".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::IdToken(value) => Field {
                    name: "idToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SessionState(value) => Field {
                    name: "sessionState".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::OauthTokenSecret(value) => Field {
                    name: "oauthTokenSecret".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::OauthToken(value) => Field {
                    name: "oauthToken".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        ProviderProviderAccountIdEquals(String, String),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
        AccountTypeEquals(String),
        AccountTypeInVec(Vec<String>),
        AccountTypeNotInVec(Vec<String>),
        AccountTypeLt(String),
        AccountTypeLte(String),
        AccountTypeGt(String),
        AccountTypeGte(String),
        AccountTypeContains(String),
        AccountTypeStartsWith(String),
        AccountTypeEndsWith(String),
        AccountTypeNot(String),
        ProviderEquals(String),
        ProviderInVec(Vec<String>),
        ProviderNotInVec(Vec<String>),
        ProviderLt(String),
        ProviderLte(String),
        ProviderGt(String),
        ProviderGte(String),
        ProviderContains(String),
        ProviderStartsWith(String),
        ProviderEndsWith(String),
        ProviderNot(String),
        ProviderAccountIdEquals(String),
        ProviderAccountIdInVec(Vec<String>),
        ProviderAccountIdNotInVec(Vec<String>),
        ProviderAccountIdLt(String),
        ProviderAccountIdLte(String),
        ProviderAccountIdGt(String),
        ProviderAccountIdGte(String),
        ProviderAccountIdContains(String),
        ProviderAccountIdStartsWith(String),
        ProviderAccountIdEndsWith(String),
        ProviderAccountIdNot(String),
        RefreshTokenEquals(Option<String>),
        RefreshTokenInVec(Vec<String>),
        RefreshTokenNotInVec(Vec<String>),
        RefreshTokenLt(String),
        RefreshTokenLte(String),
        RefreshTokenGt(String),
        RefreshTokenGte(String),
        RefreshTokenContains(String),
        RefreshTokenStartsWith(String),
        RefreshTokenEndsWith(String),
        RefreshTokenNot(String),
        RefreshTokenExpiresInEquals(Option<i32>),
        RefreshTokenExpiresInInVec(Vec<i32>),
        RefreshTokenExpiresInNotInVec(Vec<i32>),
        RefreshTokenExpiresInLt(i32),
        RefreshTokenExpiresInLte(i32),
        RefreshTokenExpiresInGt(i32),
        RefreshTokenExpiresInGte(i32),
        RefreshTokenExpiresInNot(i32),
        AccessTokenEquals(Option<String>),
        AccessTokenInVec(Vec<String>),
        AccessTokenNotInVec(Vec<String>),
        AccessTokenLt(String),
        AccessTokenLte(String),
        AccessTokenGt(String),
        AccessTokenGte(String),
        AccessTokenContains(String),
        AccessTokenStartsWith(String),
        AccessTokenEndsWith(String),
        AccessTokenNot(String),
        ExpiresAtEquals(Option<i32>),
        ExpiresAtInVec(Vec<i32>),
        ExpiresAtNotInVec(Vec<i32>),
        ExpiresAtLt(i32),
        ExpiresAtLte(i32),
        ExpiresAtGt(i32),
        ExpiresAtGte(i32),
        ExpiresAtNot(i32),
        TokenTypeEquals(Option<String>),
        TokenTypeInVec(Vec<String>),
        TokenTypeNotInVec(Vec<String>),
        TokenTypeLt(String),
        TokenTypeLte(String),
        TokenTypeGt(String),
        TokenTypeGte(String),
        TokenTypeContains(String),
        TokenTypeStartsWith(String),
        TokenTypeEndsWith(String),
        TokenTypeNot(String),
        ScopeEquals(Option<String>),
        ScopeInVec(Vec<String>),
        ScopeNotInVec(Vec<String>),
        ScopeLt(String),
        ScopeLte(String),
        ScopeGt(String),
        ScopeGte(String),
        ScopeContains(String),
        ScopeStartsWith(String),
        ScopeEndsWith(String),
        ScopeNot(String),
        IdTokenEquals(Option<String>),
        IdTokenInVec(Vec<String>),
        IdTokenNotInVec(Vec<String>),
        IdTokenLt(String),
        IdTokenLte(String),
        IdTokenGt(String),
        IdTokenGte(String),
        IdTokenContains(String),
        IdTokenStartsWith(String),
        IdTokenEndsWith(String),
        IdTokenNot(String),
        SessionStateEquals(Option<String>),
        SessionStateInVec(Vec<String>),
        SessionStateNotInVec(Vec<String>),
        SessionStateLt(String),
        SessionStateLte(String),
        SessionStateGt(String),
        SessionStateGte(String),
        SessionStateContains(String),
        SessionStateStartsWith(String),
        SessionStateEndsWith(String),
        SessionStateNot(String),
        OauthTokenSecretEquals(Option<String>),
        OauthTokenSecretInVec(Vec<String>),
        OauthTokenSecretNotInVec(Vec<String>),
        OauthTokenSecretLt(String),
        OauthTokenSecretLte(String),
        OauthTokenSecretGt(String),
        OauthTokenSecretGte(String),
        OauthTokenSecretContains(String),
        OauthTokenSecretStartsWith(String),
        OauthTokenSecretEndsWith(String),
        OauthTokenSecretNot(String),
        OauthTokenEquals(Option<String>),
        OauthTokenInVec(Vec<String>),
        OauthTokenNotInVec(Vec<String>),
        OauthTokenLt(String),
        OauthTokenLte(String),
        OauthTokenGt(String),
        OauthTokenGte(String),
        OauthTokenContains(String),
        OauthTokenStartsWith(String),
        OauthTokenEndsWith(String),
        OauthTokenNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::Utc>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtLt(chrono::DateTime<chrono::Utc>),
        CreatedAtLte(chrono::DateTime<chrono::Utc>),
        CreatedAtGt(chrono::DateTime<chrono::Utc>),
        CreatedAtGte(chrono::DateTime<chrono::Utc>),
        CreatedAtNot(chrono::DateTime<chrono::Utc>),
        UpdatedAtEquals(chrono::DateTime<chrono::Utc>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtLt(chrono::DateTime<chrono::Utc>),
        UpdatedAtLte(chrono::DateTime<chrono::Utc>),
        UpdatedAtGt(chrono::DateTime<chrono::Utc>),
        UpdatedAtGte(chrono::DateTime<chrono::Utc>),
        UpdatedAtNot(chrono::DateTime<chrono::Utc>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::ProviderProviderAccountIdEquals(provider, provider_account_id) => Field {
                    name: "provider_providerAccountId".into(),
                    fields: Some(transform_equals(
                        vec![
                            WhereParam::ProviderEquals(provider),
                            WhereParam::ProviderAccountIdEquals(provider_account_id),
                        ]
                        .into_iter()
                        .map(|f| f.to_field())
                        .collect(),
                    )),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdContains(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdStartsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdEndsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeEquals(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeInVec(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeNotInVec(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeLt(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeLte(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeGt(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeGte(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeContains(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeStartsWith(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeEndsWith(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountTypeNot(value) => Field {
                    name: "accountType".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderEquals(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderInVec(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderNotInVec(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderLt(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderLte(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderGt(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderGte(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderContains(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderStartsWith(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderEndsWith(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderNot(value) => Field {
                    name: "provider".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdEquals(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdInVec(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdNotInVec(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdLt(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdLte(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdGt(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdGte(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdContains(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdStartsWith(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdEndsWith(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProviderAccountIdNot(value) => Field {
                    name: "providerAccountId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenEquals(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenInVec(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenNotInVec(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenLt(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenLte(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenGt(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenGte(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenContains(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenStartsWith(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenEndsWith(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenNot(value) => Field {
                    name: "refreshToken".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInEquals(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInInVec(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInNotInVec(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInLt(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInLte(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInGt(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInGte(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RefreshTokenExpiresInNot(value) => Field {
                    name: "refreshTokenExpiresIn".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenEquals(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenInVec(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenNotInVec(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenLt(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenLte(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenGt(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenGte(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenContains(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenStartsWith(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenEndsWith(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccessTokenNot(value) => Field {
                    name: "accessToken".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtEquals(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtInVec(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtNotInVec(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtLt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtLte(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtGt(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtGte(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresAtNot(value) => Field {
                    name: "expiresAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeEquals(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeInVec(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeNotInVec(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeLt(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeLte(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeGt(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeGte(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeContains(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeStartsWith(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeEndsWith(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenTypeNot(value) => Field {
                    name: "tokenType".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeEquals(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeInVec(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeNotInVec(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeLt(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeLte(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeGt(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeGte(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeContains(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeStartsWith(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeEndsWith(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ScopeNot(value) => Field {
                    name: "scope".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenEquals(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenInVec(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenNotInVec(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenLt(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenLte(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenGt(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenGte(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenContains(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenStartsWith(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenEndsWith(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdTokenNot(value) => Field {
                    name: "idToken".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateEquals(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateInVec(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateNotInVec(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateLt(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateLte(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateGt(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateGte(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateContains(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateStartsWith(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateEndsWith(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SessionStateNot(value) => Field {
                    name: "sessionState".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretEquals(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretInVec(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretNotInVec(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretLt(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretLte(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretGt(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretGte(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretContains(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretStartsWith(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretEndsWith(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenSecretNot(value) => Field {
                    name: "oauthTokenSecret".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenEquals(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenInVec(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenNotInVec(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenLt(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenLte(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenGt(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenGte(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenContains(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenStartsWith(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenEndsWith(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::OauthTokenNot(value) => Field {
                    name: "oauthToken".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtEquals(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNotInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNot(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtEquals(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNotInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNot(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        ProviderProviderAccountIdEquals(String, String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::ProviderProviderAccountIdEquals(
                    provider,
                    provider_account_id,
                ) => Self::ProviderProviderAccountIdEquals(provider, provider_account_id),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Account".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Account".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            account_type: account_type::Set,
            provider: provider::Set,
            provider_account_id: provider_account_id::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(account_type).to_field());
            input_fields.push(SetParam::from(provider).to_field());
            input_fields.push(SetParam::from(provider_account_id).to_field());
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            account_type: account_type::Set,
            provider: provider::Set,
            provider_account_id: provider_account_id::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(account_type).to_field());
            input_fields.push(SetParam::from(provider).to_field());
            input_fields.push(SetParam::from(provider_account_id).to_field());
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Account".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Account".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Account".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Account".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Account".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod user {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod primary_email {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::PrimaryEmailEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PrimaryEmail(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PrimaryEmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PrimaryEmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PrimaryEmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PrimaryEmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PrimaryEmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PrimaryEmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PrimaryEmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PrimaryEmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PrimaryEmailEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PrimaryEmailNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrimaryEmail(value.0)
            }
        }
    }
    pub mod emails {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<email::WhereParam>) -> WhereParam {
            WhereParam::EmailsSome(value)
        }
        pub fn every(value: Vec<email::WhereParam>) -> WhereParam {
            WhereParam::EmailsEvery(value)
        }
        pub fn none(value: Vec<email::WhereParam>) -> WhereParam {
            WhereParam::EmailsNone(value)
        }
        pub fn fetch(params: Vec<email::WhereParam>) -> WithParam {
            WithParam::Emails(params)
        }
        pub fn link<T: From<Link>>(params: Vec<email::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<email::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkEmails(params)
        }
        pub struct Link(Vec<email::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkEmails(value.0)
            }
        }
    }
    pub mod image {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ImageEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Image(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ImageLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ImageLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ImageGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ImageGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ImageContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ImageStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ImageEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ImageNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetImage(value.0)
            }
        }
    }
    pub mod password {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<password::WhereParam>) -> WhereParam {
            WhereParam::PasswordIs(value)
        }
        pub fn is_not(value: Vec<password::WhereParam>) -> WhereParam {
            WhereParam::PasswordIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::Password
        }
        pub fn link<T: From<Link>>(value: password::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkPassword
        }
        pub struct Link(password::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkPassword(value.0)
            }
        }
    }
    pub mod accounts {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsSome(value)
        }
        pub fn every(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsEvery(value)
        }
        pub fn none(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsNone(value)
        }
        pub fn fetch(params: Vec<account::WhereParam>) -> WithParam {
            WithParam::Accounts(params)
        }
        pub fn link<T: From<Link>>(params: Vec<account::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<account::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkAccounts(params)
        }
        pub struct Link(Vec<account::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAccounts(value.0)
            }
        }
    }
    pub mod wallets {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user_wallet::WhereParam>) -> WhereParam {
            WhereParam::WalletsSome(value)
        }
        pub fn every(value: Vec<user_wallet::WhereParam>) -> WhereParam {
            WhereParam::WalletsEvery(value)
        }
        pub fn none(value: Vec<user_wallet::WhereParam>) -> WhereParam {
            WhereParam::WalletsNone(value)
        }
        pub fn fetch(params: Vec<user_wallet::WhereParam>) -> WithParam {
            WithParam::Wallets(params)
        }
        pub fn link<T: From<Link>>(params: Vec<user_wallet::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user_wallet::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkWallets(params)
        }
        pub struct Link(Vec<user_wallet::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkWallets(value.0)
            }
        }
    }
    pub mod projects {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<project::WhereParam>) -> WhereParam {
            WhereParam::ProjectsSome(value)
        }
        pub fn every(value: Vec<project::WhereParam>) -> WhereParam {
            WhereParam::ProjectsEvery(value)
        }
        pub fn none(value: Vec<project::WhereParam>) -> WhereParam {
            WhereParam::ProjectsNone(value)
        }
        pub fn fetch(params: Vec<project::WhereParam>) -> WithParam {
            WithParam::Projects(params)
        }
        pub fn link<T: From<Link>>(params: Vec<project::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<project::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkProjects(params)
        }
        pub struct Link(Vec<project::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkProjects(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("id"),
            Output::new("name"),
            Output::new("primaryEmail"),
            Output::new("image"),
            Output::new("createdAt"),
            Output::new("updatedAt"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: Option<String>,
        #[serde(rename = "primaryEmail")]
        pub primary_email: Option<String>,
        #[serde(rename = "emails")]
        emails: Option<Vec<super::email::Data>>,
        #[serde(rename = "image")]
        pub image: Option<String>,
        #[serde(rename = "password")]
        password: Option<Option<Box<super::password::Data>>>,
        #[serde(rename = "accounts")]
        accounts: Option<Vec<super::account::Data>>,
        #[serde(rename = "wallets")]
        wallets: Option<Vec<super::user_wallet::Data>>,
        #[serde(rename = "projects")]
        projects: Option<Vec<super::project::Data>>,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::Utc>,
    }
    impl Data {
        pub fn emails(&self) -> Result<&Vec<super::email::Data>, String> {
            match self.emails.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access emails but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn password(&self) -> Result<Option<&super::password::Data>, String> {
            match self.password.as_ref() {
                Some(v) => Ok(v.as_ref().map(|v| v.as_ref())),
                None => Err(
                    "Attempted to access password but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn accounts(&self) -> Result<&Vec<super::account::Data>, String> {
            match self.accounts.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access accounts but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn wallets(&self) -> Result<&Vec<super::user_wallet::Data>, String> {
            match self.wallets.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access wallets but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn projects(&self) -> Result<&Vec<super::project::Data>, String> {
            match self.projects.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access projects but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Emails(Vec<super::email::WhereParam>),
        Password,
        Accounts(Vec<super::account::WhereParam>),
        Wallets(Vec<super::user_wallet::WhereParam>),
        Projects(Vec<super::project::WhereParam>),
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::Emails(where_params) => Output {
                    name: "emails".into(),
                    outputs: super::email::_outputs(),
                    inputs: if where_params.len() > 0 {
                        vec![Input {
                            name: "where".into(),
                            fields: where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::email::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                            ..Default::default()
                        }]
                    } else {
                        vec![]
                    },
                    ..Default::default()
                },
                Self::Password => Output {
                    name: "password".into(),
                    outputs: super::password::_outputs(),
                    ..Default::default()
                },
                Self::Accounts(where_params) => Output {
                    name: "accounts".into(),
                    outputs: super::account::_outputs(),
                    inputs: if where_params.len() > 0 {
                        vec![Input {
                            name: "where".into(),
                            fields: where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::account::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                            ..Default::default()
                        }]
                    } else {
                        vec![]
                    },
                    ..Default::default()
                },
                Self::Wallets(where_params) => Output {
                    name: "wallets".into(),
                    outputs: super::user_wallet::_outputs(),
                    inputs: if where_params.len() > 0 {
                        vec![Input {
                            name: "where".into(),
                            fields: where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::user_wallet::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                            ..Default::default()
                        }]
                    } else {
                        vec![]
                    },
                    ..Default::default()
                },
                Self::Projects(where_params) => Output {
                    name: "projects".into(),
                    outputs: super::project::_outputs(),
                    inputs: if where_params.len() > 0 {
                        vec![Input {
                            name: "where".into(),
                            fields: where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::project::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                            ..Default::default()
                        }]
                    } else {
                        vec![]
                    },
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetName(Option<String>),
        SetPrimaryEmail(Option<String>),
        LinkEmails(Vec<super::email::UniqueWhereParam>),
        UnlinkEmails(Vec<super::email::UniqueWhereParam>),
        SetImage(Option<String>),
        LinkPassword(super::password::UniqueWhereParam),
        UnlinkPassword,
        LinkAccounts(Vec<super::account::UniqueWhereParam>),
        UnlinkAccounts(Vec<super::account::UniqueWhereParam>),
        LinkWallets(Vec<super::user_wallet::UniqueWhereParam>),
        UnlinkWallets(Vec<super::user_wallet::UniqueWhereParam>),
        LinkProjects(Vec<super::project::UniqueWhereParam>),
        UnlinkProjects(Vec<super::project::UniqueWhereParam>),
        SetCreatedAt(chrono::DateTime<chrono::Utc>),
        SetUpdatedAt(chrono::DateTime<chrono::Utc>),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetName(value) => Field {
                    name: "name".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetPrimaryEmail(value) => Field {
                    name: "primaryEmail".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkEmails(where_params) => Field {
                    name: "emails".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::email::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        list: true,
                        wrap_list: true,
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkEmails(where_params) => Field {
                    name: "emails".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::email::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetImage(value) => Field {
                    name: "image".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkPassword(where_param) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::password::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkPassword => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        value: Some(true.into()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::LinkAccounts(where_params) => Field {
                    name: "accounts".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::account::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        list: true,
                        wrap_list: true,
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkAccounts(where_params) => Field {
                    name: "accounts".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::account::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::LinkWallets(where_params) => Field {
                    name: "wallets".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::user_wallet::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        list: true,
                        wrap_list: true,
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkWallets(where_params) => Field {
                    name: "wallets".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::user_wallet::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::LinkProjects(where_params) => Field {
                    name: "projects".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::project::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        list: true,
                        wrap_list: true,
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkProjects(where_params) => Field {
                    name: "projects".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::project::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetCreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
        PrimaryEmail(Direction),
        Image(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Name(direction) => Field {
                    name: "name".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::PrimaryEmail(direction) => Field {
                    name: "primaryEmail".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Image(direction) => Field {
                    name: "image".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(direction) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(direction) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Name(String),
        PrimaryEmail(String),
        Image(String),
        CreatedAt(chrono::DateTime<chrono::Utc>),
        UpdatedAt(chrono::DateTime<chrono::Utc>),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Name(value) => Field {
                    name: "name".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::PrimaryEmail(value) => Field {
                    name: "primaryEmail".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Image(value) => Field {
                    name: "image".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        NameEquals(Option<String>),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameNot(String),
        PrimaryEmailEquals(Option<String>),
        PrimaryEmailInVec(Vec<String>),
        PrimaryEmailNotInVec(Vec<String>),
        PrimaryEmailLt(String),
        PrimaryEmailLte(String),
        PrimaryEmailGt(String),
        PrimaryEmailGte(String),
        PrimaryEmailContains(String),
        PrimaryEmailStartsWith(String),
        PrimaryEmailEndsWith(String),
        PrimaryEmailNot(String),
        EmailsSome(Vec<super::email::WhereParam>),
        EmailsEvery(Vec<super::email::WhereParam>),
        EmailsNone(Vec<super::email::WhereParam>),
        ImageEquals(Option<String>),
        ImageInVec(Vec<String>),
        ImageNotInVec(Vec<String>),
        ImageLt(String),
        ImageLte(String),
        ImageGt(String),
        ImageGte(String),
        ImageContains(String),
        ImageStartsWith(String),
        ImageEndsWith(String),
        ImageNot(String),
        PasswordIs(Vec<super::password::WhereParam>),
        PasswordIsNot(Vec<super::password::WhereParam>),
        AccountsSome(Vec<super::account::WhereParam>),
        AccountsEvery(Vec<super::account::WhereParam>),
        AccountsNone(Vec<super::account::WhereParam>),
        WalletsSome(Vec<super::user_wallet::WhereParam>),
        WalletsEvery(Vec<super::user_wallet::WhereParam>),
        WalletsNone(Vec<super::user_wallet::WhereParam>),
        ProjectsSome(Vec<super::project::WhereParam>),
        ProjectsEvery(Vec<super::project::WhereParam>),
        ProjectsNone(Vec<super::project::WhereParam>),
        CreatedAtEquals(chrono::DateTime<chrono::Utc>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtLt(chrono::DateTime<chrono::Utc>),
        CreatedAtLte(chrono::DateTime<chrono::Utc>),
        CreatedAtGt(chrono::DateTime<chrono::Utc>),
        CreatedAtGte(chrono::DateTime<chrono::Utc>),
        CreatedAtNot(chrono::DateTime<chrono::Utc>),
        UpdatedAtEquals(chrono::DateTime<chrono::Utc>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtLt(chrono::DateTime<chrono::Utc>),
        UpdatedAtLte(chrono::DateTime<chrono::Utc>),
        UpdatedAtGt(chrono::DateTime<chrono::Utc>),
        UpdatedAtGte(chrono::DateTime<chrono::Utc>),
        UpdatedAtNot(chrono::DateTime<chrono::Utc>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdContains(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdStartsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdEndsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameEquals(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameInVec(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameNotInVec(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameLt(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameLte(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameGt(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameGte(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameContains(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameStartsWith(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameEndsWith(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NameNot(value) => Field {
                    name: "name".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailEquals(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailInVec(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailNotInVec(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailLt(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailLte(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailGt(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailGte(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailContains(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailStartsWith(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailEndsWith(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PrimaryEmailNot(value) => Field {
                    name: "primaryEmail".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailsSome(value) => Field {
                    name: "emails".into(),
                    fields: Some(vec![Field {
                        name: "some".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailsEvery(value) => Field {
                    name: "emails".into(),
                    fields: Some(vec![Field {
                        name: "every".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailsNone(value) => Field {
                    name: "emails".into(),
                    fields: Some(vec![Field {
                        name: "none".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageEquals(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageInVec(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageNotInVec(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageLt(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageLte(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageGt(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageGte(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageContains(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageStartsWith(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageEndsWith(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ImageNot(value) => Field {
                    name: "image".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordIs(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordIsNot(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountsSome(value) => Field {
                    name: "accounts".into(),
                    fields: Some(vec![Field {
                        name: "some".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountsEvery(value) => Field {
                    name: "accounts".into(),
                    fields: Some(vec![Field {
                        name: "every".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccountsNone(value) => Field {
                    name: "accounts".into(),
                    fields: Some(vec![Field {
                        name: "none".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::WalletsSome(value) => Field {
                    name: "wallets".into(),
                    fields: Some(vec![Field {
                        name: "some".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::WalletsEvery(value) => Field {
                    name: "wallets".into(),
                    fields: Some(vec![Field {
                        name: "every".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::WalletsNone(value) => Field {
                    name: "wallets".into(),
                    fields: Some(vec![Field {
                        name: "none".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProjectsSome(value) => Field {
                    name: "projects".into(),
                    fields: Some(vec![Field {
                        name: "some".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProjectsEvery(value) => Field {
                    name: "projects".into(),
                    fields: Some(vec![Field {
                        name: "every".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ProjectsNone(value) => Field {
                    name: "projects".into(),
                    fields: Some(vec![Field {
                        name: "none".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtEquals(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNotInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNot(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtEquals(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNotInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNot(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "User".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "User".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(mut self, params: Vec<SetParam>) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, params: Vec<SetParam>) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod email {
    use super::*;
    pub mod email {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals<A, T: prisma_client_rust::traits::FromOptionalUniqueArg<Set, Arg = A>>(
            value: A,
        ) -> T {
            T::from_arg(value)
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Email(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
    }
    pub mod email_verified {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<chrono::DateTime<chrono::Utc>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::EmailVerifiedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::EmailVerified(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::EmailVerifiedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::EmailVerifiedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::EmailVerifiedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::EmailVerifiedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::EmailVerifiedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::EmailVerifiedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::EmailVerifiedNot(value)
        }
        pub struct Set(Option<chrono::DateTime<chrono::Utc>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmailVerified(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::UserId(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("email"),
            Output::new("emailVerified"),
            Output::new("userId"),
            Output::new("createdAt"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "email")]
        pub email: Option<String>,
        #[serde(rename = "emailVerified")]
        pub email_verified: Option<chrono::DateTime<chrono::Utc>>,
        #[serde(rename = "userId")]
        pub user_id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetEmail(Option<String>),
        SetEmailVerified(Option<chrono::DateTime<chrono::Utc>>),
        SetUserId(String),
        SetCreatedAt(chrono::DateTime<chrono::Utc>),
        LinkUser(super::user::UniqueWhereParam),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetEmail(value) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetEmailVerified(value) => Field {
                    name: "emailVerified".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetCreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Email(Direction),
        EmailVerified(Direction),
        UserId(Direction),
        CreatedAt(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Email(direction) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::EmailVerified(direction) => Field {
                    name: "emailVerified".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(direction) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Email(String),
        EmailVerified(chrono::DateTime<chrono::Utc>),
        UserId(String),
        CreatedAt(chrono::DateTime<chrono::Utc>),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Email(value) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::EmailVerified(value) => Field {
                    name: "emailVerified".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        EmailEquals(Option<String>),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailNot(String),
        EmailVerifiedEquals(Option<chrono::DateTime<chrono::Utc>>),
        EmailVerifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
        EmailVerifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        EmailVerifiedLt(chrono::DateTime<chrono::Utc>),
        EmailVerifiedLte(chrono::DateTime<chrono::Utc>),
        EmailVerifiedGt(chrono::DateTime<chrono::Utc>),
        EmailVerifiedGte(chrono::DateTime<chrono::Utc>),
        EmailVerifiedNot(chrono::DateTime<chrono::Utc>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::Utc>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtLt(chrono::DateTime<chrono::Utc>),
        CreatedAtLte(chrono::DateTime<chrono::Utc>),
        CreatedAtGt(chrono::DateTime<chrono::Utc>),
        CreatedAtGte(chrono::DateTime<chrono::Utc>),
        CreatedAtNot(chrono::DateTime<chrono::Utc>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::EmailEquals(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailInVec(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailNotInVec(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailLt(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailLte(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailGt(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailGte(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailContains(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailStartsWith(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailEndsWith(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailNot(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedEquals(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedInVec(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedNotInVec(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedLt(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedLte(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedGt(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedGte(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailVerifiedNot(value) => Field {
                    name: "emailVerified".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtEquals(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNotInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNot(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        EmailEquals(String),
        UserIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(Some(value)),
                UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
            }
        }
    }
    impl prisma_client_rust::traits::FromOptionalUniqueArg<email::Set> for WhereParam {
        type Arg = Option<String>;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::EmailEquals(arg)
        }
    }
    impl prisma_client_rust::traits::FromOptionalUniqueArg<email::Set> for UniqueWhereParam {
        type Arg = String;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::EmailEquals(arg)
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Email".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Email".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(mut self, user: user::Link, params: Vec<SetParam>) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, user: user::Link, params: Vec<SetParam>) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Email".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Email".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Email".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Email".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Email".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod verification_token {
    use super::*;
    pub mod identifier {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::IdentifierEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Identifier(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdentifierInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdentifierNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdentifierLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdentifierLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdentifierGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdentifierGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdentifierContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdentifierStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdentifierEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdentifierNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIdentifier(value.0)
            }
        }
    }
    pub mod token {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::TokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Token(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Token(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TokenNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetToken(value.0)
            }
        }
    }
    pub mod expires {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Expires(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::ExpiresInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::ExpiresNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::ExpiresNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpires(value.0)
            }
        }
    }
    pub fn identifier_token<T: From<UniqueWhereParam>>(identifier: String, token: String) -> T {
        UniqueWhereParam::IdentifierTokenEquals(identifier, token).into()
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("identifier"),
            Output::new("token"),
            Output::new("expires"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "identifier")]
        pub identifier: String,
        #[serde(rename = "token")]
        pub token: String,
        #[serde(rename = "expires")]
        pub expires: chrono::DateTime<chrono::Utc>,
    }
    impl Data {}
    pub enum WithParam {}
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {}
        }
    }
    pub enum SetParam {
        SetIdentifier(String),
        SetToken(String),
        SetExpires(chrono::DateTime<chrono::Utc>),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetIdentifier(value) => Field {
                    name: "identifier".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetToken(value) => Field {
                    name: "token".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetExpires(value) => Field {
                    name: "expires".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Identifier(Direction),
        Token(Direction),
        Expires(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Identifier(direction) => Field {
                    name: "identifier".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Token(direction) => Field {
                    name: "token".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Expires(direction) => Field {
                    name: "expires".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Identifier(String),
        Token(String),
        Expires(chrono::DateTime<chrono::Utc>),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Identifier(value) => Field {
                    name: "identifier".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Token(value) => Field {
                    name: "token".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Expires(value) => Field {
                    name: "expires".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdentifierTokenEquals(String, String),
        IdentifierEquals(String),
        IdentifierInVec(Vec<String>),
        IdentifierNotInVec(Vec<String>),
        IdentifierLt(String),
        IdentifierLte(String),
        IdentifierGt(String),
        IdentifierGte(String),
        IdentifierContains(String),
        IdentifierStartsWith(String),
        IdentifierEndsWith(String),
        IdentifierNot(String),
        TokenEquals(String),
        TokenInVec(Vec<String>),
        TokenNotInVec(Vec<String>),
        TokenLt(String),
        TokenLte(String),
        TokenGt(String),
        TokenGte(String),
        TokenContains(String),
        TokenStartsWith(String),
        TokenEndsWith(String),
        TokenNot(String),
        ExpiresEquals(chrono::DateTime<chrono::Utc>),
        ExpiresInVec(Vec<chrono::DateTime<chrono::Utc>>),
        ExpiresNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        ExpiresLt(chrono::DateTime<chrono::Utc>),
        ExpiresLte(chrono::DateTime<chrono::Utc>),
        ExpiresGt(chrono::DateTime<chrono::Utc>),
        ExpiresGte(chrono::DateTime<chrono::Utc>),
        ExpiresNot(chrono::DateTime<chrono::Utc>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdentifierTokenEquals(identifier, token) => Field {
                    name: "identifier_token".into(),
                    fields: Some(transform_equals(
                        vec![
                            WhereParam::IdentifierEquals(identifier),
                            WhereParam::TokenEquals(token),
                        ]
                        .into_iter()
                        .map(|f| f.to_field())
                        .collect(),
                    )),
                    ..Default::default()
                },
                Self::IdentifierEquals(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierInVec(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierNotInVec(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierLt(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierLte(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierGt(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierGte(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierContains(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierStartsWith(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierEndsWith(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdentifierNot(value) => Field {
                    name: "identifier".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenEquals(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenInVec(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenNotInVec(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenLt(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenLte(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenGt(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenGte(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenContains(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenStartsWith(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenEndsWith(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenNot(value) => Field {
                    name: "token".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresEquals(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresInVec(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresNotInVec(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresLt(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresLte(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresGt(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresGte(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ExpiresNot(value) => Field {
                    name: "expires".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdentifierTokenEquals(String, String),
        TokenEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdentifierTokenEquals(identifier, token) => {
                    Self::IdentifierTokenEquals(identifier, token)
                }
                UniqueWhereParam::TokenEquals(value) => Self::TokenEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "VerificationToken".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "VerificationToken".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            identifier: identifier::Set,
            token: token::Set,
            expires: expires::Set,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(identifier).to_field());
            input_fields.push(SetParam::from(token).to_field());
            input_fields.push(SetParam::from(expires).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            identifier: identifier::Set,
            token: token::Set,
            expires: expires::Set,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(identifier).to_field());
            input_fields.push(SetParam::from(token).to_field());
            input_fields.push(SetParam::from(expires).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "VerificationToken".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "VerificationToken".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "VerificationToken".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "VerificationToken".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "VerificationToken".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod user_wallet {
    use super::*;
    pub mod public_key {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::PublicKeyEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PublicKey(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::PublicKey(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PublicKeyInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PublicKeyNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PublicKeyLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PublicKeyLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PublicKeyGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PublicKeyGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PublicKeyContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PublicKeyStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PublicKeyEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PublicKeyNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPublicKey(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("publicKey"),
            Output::new("userId"),
            Output::new("createdAt"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "publicKey")]
        pub public_key: String,
        #[serde(rename = "userId")]
        pub user_id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetPublicKey(String),
        SetUserId(String),
        SetCreatedAt(chrono::DateTime<chrono::Utc>),
        LinkUser(super::user::UniqueWhereParam),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetPublicKey(value) => Field {
                    name: "publicKey".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetCreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        PublicKey(Direction),
        UserId(Direction),
        CreatedAt(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::PublicKey(direction) => Field {
                    name: "publicKey".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(direction) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        PublicKey(String),
        UserId(String),
        CreatedAt(chrono::DateTime<chrono::Utc>),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::PublicKey(value) => Field {
                    name: "publicKey".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        PublicKeyEquals(String),
        PublicKeyInVec(Vec<String>),
        PublicKeyNotInVec(Vec<String>),
        PublicKeyLt(String),
        PublicKeyLte(String),
        PublicKeyGt(String),
        PublicKeyGte(String),
        PublicKeyContains(String),
        PublicKeyStartsWith(String),
        PublicKeyEndsWith(String),
        PublicKeyNot(String),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::Utc>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtLt(chrono::DateTime<chrono::Utc>),
        CreatedAtLte(chrono::DateTime<chrono::Utc>),
        CreatedAtGt(chrono::DateTime<chrono::Utc>),
        CreatedAtGte(chrono::DateTime<chrono::Utc>),
        CreatedAtNot(chrono::DateTime<chrono::Utc>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::PublicKeyEquals(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyInVec(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyNotInVec(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyLt(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyLte(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyGt(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyGte(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyContains(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyStartsWith(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyEndsWith(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PublicKeyNot(value) => Field {
                    name: "publicKey".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtEquals(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNotInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNot(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        PublicKeyEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::PublicKeyEquals(value) => Self::PublicKeyEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "UserWallet".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "UserWallet".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            public_key: public_key::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(public_key).to_field());
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            public_key: public_key::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(public_key).to_field());
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "UserWallet".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "UserWallet".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "UserWallet".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "UserWallet".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "UserWallet".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod password {
    use super::*;
    pub mod hash {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::HashEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Hash(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HashLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HashLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HashGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HashGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HashContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HashStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HashEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HashNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHash(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::UserId(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![Output::new("hash"), Output::new("userId")]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "hash")]
        pub hash: String,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetHash(String),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(String),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetHash(value) => Field {
                    name: "hash".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Hash(Direction),
        UserId(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Hash(direction) => Field {
                    name: "hash".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Hash(String),
        UserId(String),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Hash(value) => Field {
                    name: "hash".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        HashEquals(String),
        HashInVec(Vec<String>),
        HashNotInVec(Vec<String>),
        HashLt(String),
        HashLte(String),
        HashGt(String),
        HashGte(String),
        HashContains(String),
        HashStartsWith(String),
        HashEndsWith(String),
        HashNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::HashEquals(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashInVec(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashNotInVec(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashLt(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashLte(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashGt(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashGte(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashContains(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashStartsWith(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashEndsWith(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::HashNot(value) => Field {
                    name: "hash".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        UserIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Password".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Password".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(mut self, hash: hash::Set, user: user::Link, params: Vec<SetParam>) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(hash).to_field());
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, hash: hash::Set, user: user::Link, params: Vec<SetParam>) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(hash).to_field());
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Password".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Password".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Password".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Password".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Password".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod project {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DescriptionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DescriptionLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DescriptionLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DescriptionGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DescriptionGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DescriptionContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DescriptionStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DescriptionEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DescriptionNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::Utc>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::Utc>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::Utc>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::Utc>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("id"),
            Output::new("title"),
            Output::new("description"),
            Output::new("createdAt"),
            Output::new("updatedAt"),
            Output::new("userId"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::Utc>,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetTitle(String),
        SetDescription(String),
        SetCreatedAt(chrono::DateTime<chrono::Utc>),
        SetUpdatedAt(chrono::DateTime<chrono::Utc>),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(String),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetTitle(value) => Field {
                    name: "title".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDescription(value) => Field {
                    name: "description".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetCreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Title(Direction),
        Description(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        UserId(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Title(direction) => Field {
                    name: "title".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Description(direction) => Field {
                    name: "description".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(direction) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(direction) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Title(String),
        Description(String),
        CreatedAt(chrono::DateTime<chrono::Utc>),
        UpdatedAt(chrono::DateTime<chrono::Utc>),
        UserId(String),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Title(value) => Field {
                    name: "title".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Description(value) => Field {
                    name: "description".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::CreatedAt(value) => Field {
                    name: "createdAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UpdatedAt(value) => Field {
                    name: "updatedAt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        TitleEquals(String),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleNot(String),
        DescriptionEquals(String),
        DescriptionInVec(Vec<String>),
        DescriptionNotInVec(Vec<String>),
        DescriptionLt(String),
        DescriptionLte(String),
        DescriptionGt(String),
        DescriptionGte(String),
        DescriptionContains(String),
        DescriptionStartsWith(String),
        DescriptionEndsWith(String),
        DescriptionNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::Utc>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        CreatedAtLt(chrono::DateTime<chrono::Utc>),
        CreatedAtLte(chrono::DateTime<chrono::Utc>),
        CreatedAtGt(chrono::DateTime<chrono::Utc>),
        CreatedAtGte(chrono::DateTime<chrono::Utc>),
        CreatedAtNot(chrono::DateTime<chrono::Utc>),
        UpdatedAtEquals(chrono::DateTime<chrono::Utc>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
        UpdatedAtLt(chrono::DateTime<chrono::Utc>),
        UpdatedAtLte(chrono::DateTime<chrono::Utc>),
        UpdatedAtGt(chrono::DateTime<chrono::Utc>),
        UpdatedAtGte(chrono::DateTime<chrono::Utc>),
        UpdatedAtNot(chrono::DateTime<chrono::Utc>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdContains(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdStartsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdEndsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleEquals(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleInVec(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleNotInVec(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleLt(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleLte(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleGt(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleGte(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleContains(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleStartsWith(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleEndsWith(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TitleNot(value) => Field {
                    name: "title".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionEquals(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionInVec(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionNotInVec(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionLt(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionLte(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionGt(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionGte(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionContains(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionStartsWith(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionEndsWith(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DescriptionNot(value) => Field {
                    name: "description".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtEquals(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNotInVec(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtLte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGt(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtGte(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::CreatedAtNot(value) => Field {
                    name: "createdAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtEquals(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNotInVec(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtLte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGt(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtGte(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UpdatedAtNot(value) => Field {
                    name: "updatedAt".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Project".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Project".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            title: title::Set,
            description: description::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(title).to_field());
            input_fields.push(SetParam::from(description).to_field());
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            title: title::Set,
            description: description::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(title).to_field());
            input_fields.push(SetParam::from(description).to_field());
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Project".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Project".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Project".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Project".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Project".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum AccountScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "accountType")]
    AccountType,
    #[serde(rename = "provider")]
    Provider,
    #[serde(rename = "providerAccountId")]
    ProviderAccountId,
    #[serde(rename = "refreshToken")]
    RefreshToken,
    #[serde(rename = "refreshTokenExpiresIn")]
    RefreshTokenExpiresIn,
    #[serde(rename = "accessToken")]
    AccessToken,
    #[serde(rename = "expiresAt")]
    ExpiresAt,
    #[serde(rename = "tokenType")]
    TokenType,
    #[serde(rename = "scope")]
    Scope,
    #[serde(rename = "idToken")]
    IdToken,
    #[serde(rename = "sessionState")]
    SessionState,
    #[serde(rename = "oauthTokenSecret")]
    OauthTokenSecret,
    #[serde(rename = "oauthToken")]
    OauthToken,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "primaryEmail")]
    PrimaryEmail,
    #[serde(rename = "image")]
    Image,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum EmailScalarFieldEnum {
    #[serde(rename = "email")]
    Email,
    #[serde(rename = "emailVerified")]
    EmailVerified,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "createdAt")]
    CreatedAt,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum VerificationTokenScalarFieldEnum {
    #[serde(rename = "identifier")]
    Identifier,
    #[serde(rename = "token")]
    Token,
    #[serde(rename = "expires")]
    Expires,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserWalletScalarFieldEnum {
    #[serde(rename = "publicKey")]
    PublicKey,
    #[serde(rename = "userId")]
    UserId,
    #[serde(rename = "createdAt")]
    CreatedAt,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum PasswordScalarFieldEnum {
    #[serde(rename = "hash")]
    Hash,
    #[serde(rename = "userId")]
    UserId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ProjectScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "title")]
    Title,
    #[serde(rename = "description")]
    Description,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
    #[serde(rename = "userId")]
    UserId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
}
